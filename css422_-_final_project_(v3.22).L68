00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.4.0
Created On: 6/12/2010 11:44:42 AM

00000000                             1  *-------------------------------------------------------------------------------
00000000                             2  * Program    : Final Project (ver 3.2.2)
00000000                             3  * Written by : Aaron Parks, Neal Natsheh, Mark Shipman
00000000                             4  * Date       : 29 May 2010
00000000                             5  * Description: Will dissassemble a program loaded to memory.
00000000                             6  *
00000000                             7  *    Part 1: Will prompt user for a starting and ending address value where the
00000000                             8  *    the program is located in memory. Error checking will be performed on the
00000000                             9  *    user input. If the user input is not correct as per the displayed input
00000000                            10  *    parameters, user will be prompted again. When correct input is detected, 
00000000                            11  *    addresses will be stored.
00000000                            12  *    Program API: A0 -
00000000                            13  *                 A1 - pointer to string location
00000000                            14  *                 A2 - 
00000000                            15  *                 A3 - USED BY SUBROUTINES ONLY
00000000                            16  *                 A4 - holds starting address
00000000                            17  *                 A5 - holds ending address
00000000                            18  *                 A6 - temp storage for address comparison
00000000                            19  *                 D0 - holds task number
00000000                            20  *                 D1 - holds string length
00000000                            21  *                 D2 -
00000000                            22  *                 D3 -
00000000                            23  *                 D4 -
00000000                            24  *                 D5 -
00000000                            25  *                 D6 - temp storage for ascii patterns
00000000                            26  *                 D7 - converted characaters for addresses
00000000                            27  *
00000000                            28  *    Part 2:
00000000                            29  *    Program API: A0 - pointer to storage for patterns
00000000                            30  *                 A1 - pointer to storage for binary of word / good_buffer / bad_buffer
00000000                            31  *                 A2 - USED FOR SUBROUTINES ONLY
00000000                            32  *                 A3 - USED FOR SUBROUTINES ONLY
00000000                            33  *                 A4 - holds starting address
00000000                            34  *                 A5 - holds ending address
00000000                            35  *                 A6 - flag pointer
00000000                            36  *                 D0 - word read in from memory
00000000                            37  *                 D1 - temp holder for word read from memory
00000000                            38  *                 D2 - holds first four MSB for comparison / temp copy of word in D0
00000000                            39  *                 D3 - Effective Address register size
00000000                            40  *                 D4 -
00000000                            41  *                 D5 - USED FOR SUBROUTINES ONLY
00000000                            42  *                 D6 - USED FOR SUBROUTINES ONLY
00000000                            43  *                 D7 - USED FOR SUBROUTINES ONLY
00000000                            44  *-------------------------------------------------------------------------------
00000000                            45              OPT         CRE
00000000                            46  *-------------------------------------------------------------------------------
00000000                            47  *           EQU - Ascii Values
00000000                            48  *-------------------------------------------------------------------------------
00000000  =0000000A                 49  newline     EQU         $0A                     * ascii value for new line
00000000  =0000000D                 50  return      EQU         $0D                     * ascii value for carriage return
00000000  =0000001A                 51  sub         EQU         $1A                     * ascii value for substitution
00000000  =00000020                 52  space       EQU         $20                     * ascii value for space
00000000  =00002020                 53  dspace      EQU         $2020                   * double space
00000000  =20202020                 54  qspace      EQU         $20202020               * quad spacing
00000000  =00000023                 55  num         EQU         $23                     * ascii value for pound
00000000  =00000024                 56  hex         EQU         $24                     * ascii value for dollar
00000000  =00000025                 57  bin         EQU         $25                     * ascii value for percentage
00000000  =00000028                 58  opp         EQU         $28                     * ascii value for open paren
00000000  =00000029                 59  clp         EQU         $29                     * ascii value for closed paren
00000000  =0000002B                 60  plus        EQU         $2B                     * ascii value for plus
00000000  =0000002C                 61  comma       EQU         $2C                     * ascii value for comma
00000000  =0000002D                 62  minus       EQU         $2D                     * ascii value for minus
00000000  =0000002E                 63  dot         EQU         $2E                     * ascii value for period
00000000  =00000042                 64  byte        EQU         $42                     * ascii value for B
00000000  =0000004C                 65  long        EQU         $4C                     * ascii value for L
00000000  =00000057                 66  word        EQU         $57                     * ascii value for W
00000000  =00000059                 67  yes1        EQU         $59                     * ascii value for y
00000000  =00000079                 68  yes2        EQU         $79                     * ascii value for Y
00000000                            69  *-------------------------------------------------------------------------------
00000000                            70  *           Tasks for I/O
00000000                            71  *-------------------------------------------------------------------------------    
00000000  =00000000                 72  tsk0        EQU         $00                     * display with newline
00000000  =00000001                 73  tsk1        EQU         $01                     * display without newline
00000000  =00000002                 74  tsk2        EQU         $02                     * accept user input
00000000                            75  *-------------------------------------------------------------------------------
00000000                            76  *           EQU - 
00000000                            77  *-------------------------------------------------------------------------------
00000000  =00001000                 78  start_bnds  EQU         $00001000               * lower address bounds
00000000  =000FFFFF                 79  end_bnds    EQU         $000FFFFF               * upper address bounds
00000000  =00A00000                 80  stk_ptr     EQU         $00A00000               * start of stack
00000000                            81  
00000000  =00000004                 82  shift       EQU         4                       * shift distance
00000000  =00000001                 83  increment   EQU         1                       * increment amount
00000000  =00000030                 84  n_key       EQU         $30                     * subtraction value for numbers
00000000  =00000037                 85  u_key       EQU         $37                     * subtraction value for uppercase
00000000  =00000057                 86  l_key       EQU         $57                     * subtraction value for lowercase
00000000  =00000004                 87  addcnt      EQU         $04                     * used to convert mem add to ASCII
00000000  =00000002                 88  pattcnt     EQU         $02                     * used to convert pattern to ASCII
00000000  =00000001                 89  dec_cnt     EQU         00000001                * used to decrement counter by 1
00000000  =00000000                 90  empty_cnt   EQU         00000000                * to check if max # error cnt reached
00000000                            91  *-------------------------------------------------------------------------------
00000000                            92  *           MASKS
00000000                            93  *-------------------------------------------------------------------------------
00000000                            94  * for converting entire long
00000000  =FF000000                 95  mask_byte1  EQU         $FF000000               * isolate byte 4
00000000  =00FF0000                 96  mask_byte2  EQU         $00FF0000               * isolate byte 3
00000000  =0000FF00                 97  mask_byte3  EQU         $0000FF00               * isolate byte 2
00000000  =000000FF                 98  mask_byte4  EQU         $000000FF               * isolate byte 1        
00000000                            99  * for generating binary for word
00000000  =000000F0                100  mask_left   EQU         $00F0                   * isolate left nibble
00000000  =0000000F                101  mask_right  EQU         $000F                   * isolate right nibble
00000000                           102  * for isolation in add
00000000  =000FFF00                103  arith_mask1 EQU         $000FFF00               * isolate opmode
00000000  =FFF00000                104  arith_mask2 EQU         $FFF00000               * isolate register
00000000  =000000FF                105  arith_mask3 EQU         $000000FF               * determine when to pass to EA
00000000  =00FFFFFF                106  arith_mask4 EQU         $00FFFFFF               * isolate EA bits
00000000  =0000FFF0                107  arith_mask5 EQU         $0000FFF0               * second mask used to isolate register bits
00000000                           108  * for isolation in specials and exchange
00000000  =00000040                109  bit6_mask   EQU         $0040                   * isolate bit 6
00000000  =00000100                110  bit8_mask   EQU         $0100                   * isolate bit 8
00000000  =00000200                111  bit9_mask   EQU         $0200                   * isolate bit 9
00000000  =00000E00                112  b911_mask   EQU         $0E00                   * isolate bits 9 - 11
00000000  =000001C0                113  b68_mask    EQU         $01C0                   * isolate bits 6 - 8
00000000  =00000030                114  b45_mask    EQU         $0030                   * isolate bits 4 and 5
00000000  =00000078                115  b37_mask    EQU         $0078                   * isolate bits 3 - 7 (exg mode)
00000000  =00000038                116  b35_mask    EQU         $0038                   * isolate bits 3 - 5 (ea mode)
00000000  =000000C0                117  size_mask   EQU         $00C0                   * isolate bits 6 and 7 (for CLR and NEG)
00000000  =00000007                118  swap_mask   EQU         $0007                   * isolate bits 0 - 2
00000000  =00000400                119  movm_mask   EQU         $0400                   * isolate bit 10        
00000000                           120  * for effective addressing
00000000  =0000003F                121  ea_mask0    EQU         $0000003F               * zero all bits but EA bits
00000000  =00FFF000                122  ea_mask1    EQU         $00FFF000               * isolate mode
00000000  =00000FFF                123  ea_mask2    EQU         $00000FFF               * isolate register
00000000  =00000FC0                124  ea_mask3    EQU         $00000FC0               * zero all bits but EA bits
00000000                           125  * other masks
00000000  =000001C0                126  opmd_mask   EQU         $01C0                   * isolates bits for opmode (standard location)
00000000  =00000E00                127  reg_mask    EQU         $0E00                   * isolates bits for register (standard location)
00000000  =000000F0                128  addr_mask1  EQU         $000000F0               * used to convert 1st nibble to ASCII
00000000  =0000000F                129  addr_mask2  EQU         $0000000F               * used to convert 2nd nibble to ASCII
00000000  =FFFFFFFE                130  mask_even   EQU         $FFFFFFFE               * for making addresses even
00000000                           131  * for isolation in immediate opcode subroutine
00000000  =FF000000                132  imm_mask1   EQU         $FF000000               * isolate the size
00000000  =00FFFFFF                133  imm_mask2   EQU         $00FFFFFF               * isolate the ea section of immediates
00000000                           134  * masks used to convert from hex to ASCII
00000000  =0000FF00                135  hToAMask_1  EQU         $0000FF00               * isolate left byte
00000000  =000000FF                136  hToAMask_2  EQU         $000000FF               * isolate right byte
00000000                           137  * masks used for bit manipulations
00000000  =0000FF00                138  manip_mask1 EQU         $0000FF00               * isolate the size
00000000  =000FF000                139  manip_mask2 EQU         $000FF000               * isolate bits 4/3
00000000  =0000000F                140  manip_mask3 EQU         $0000000F               * isolate direction
00000000  =00F00000                141  manip_mask4 EQU         $00F00000               * isolate i/r bit
00000000  =0000FFF0                142  manip_mask5 EQU         $0000FFF0               * isolate count
00000000  =00000FFF                143  manip_mask6 EQU         $00000FFF               * isolate register
00000000  =FF000000                144  manip_mask7 EQU         $FF000000               * isolate the size
00000000  =00FFFFFF                145  manip_mask8 EQU         $00FFFFFF
00000000                           146  * masks used for BSR command
00000000  =FFFF0000                147  bsr_mask1   EQU         $FFFF0000               * isolate left 4 bits of displace
00000000  =0000FFFF                148  bsr_mask2   EQU         $0000FFFF               * isolate left 4 bits of displace
00000000  =FFFFFF00                149  gen_mask    EQU         $FFFFFF00               * isolae MOVE destination EA bits
00000000                           150  * masks used for and / exg
00000000  =0000000F                151  and_mask1   EQU         $0000000F               * isolate bit #8
00000000  =FFFFF000                152  and_mask2   EQU         $FFFFF000               * isolate opmode
00000000  =0000FF00                153  and_mask3   EQU         $0000FF00               * isolate right two bits of op
00000000  =0000FFF0                154  and_mask4   EQU         $0000FFF0               * isolate register value
00000000  =00000FFF                155  and_mask5   EQU         $00000FFF               * isolate second register value
00000000                           156  *-------------------------------------------------------------------------------
00000000                           157  *           MODES
00000000                           158  *-------------------------------------------------------------------------------
00000000  =00000000                159  mode0       EQU         $0000                   * mode zero
00000000  =00000001                160  mode1       EQU         $0001                   * mode one
00000000  =00000010                161  mode2       EQU         $0010                   * mode two
00000000  =00000011                162  mode3       EQU         $0011                   * mode three
00000000  =00000100                163  mode4       EQU         $0100                   * mode four
00000000  =00000101                164  mode5       EQU         $0101                   * mode five
00000000  =00000110                165  mode6       EQU         $0110                   * mode six
00000000  =00000111                166  mode7       EQU         $0111                   * mode seven
00000000                           167  *-------------------------------------------------------------------------------
00000000                           168  *           REGISTER VALUES (EFFECTIVE ADDRESS)
00000000                           169  *-------------------------------------------------------------------------------
00000000  =00000000                170  reg0        EQU         0                       * value zero
00000000  =00000001                171  reg1        EQU         1                       * value one
00000000  =00000004                172  reg4        EQU         4                       * value four
00000000                           173  *-------------------------------------------------------------------------------
00000000                           174  *           IMMEDIATE OPCODES
00000000                           175  *-------------------------------------------------------------------------------
00000000  =00000110                176  addi_opcode EQU         $0110                   * compare for ADDI
00000000  =00000010                177  andi_opcode EQU         $0010                   * compare for ANDI
00000000  =00001100                178  cmpi_opcode EQU         $1100                   * compare for CMPI
00000000  =00001010                179  eori_opcode EQU         $1010                   * compare for EORI
00000000  =00000000                180  ori_opcode  EQU         $0000                   * compare for ORI
00000000  =00000100                181  subi_opcode EQU         $0100                   * compare for SUBI
00000000                           182  *-------------------------------------------------------------------------------
00000000                           183  *           MISC VALUES
00000000                           184  *-------------------------------------------------------------------------------
00000000  =00000001                185  increment   EQU         1                       * increment amount
00000000  =00000002                186  loop        EQU         2                       * number of times to loop
00000000  =000000FF                187  bad         EQU         $FF                     * value of bad flag
00000000  =00000000                188  good        EQU         $00                     * value of good flag
00000000  =00000000                189  reset       EQU         $00                     * zero (for counter)
00000000  =00000000                190  empty       EQU         $00000000               * used to zero a register
00000000  =00004D71                191  nop_opcode  EQU         $4D71                   * compare for NOP
00000000  =00004D75                192  rts_opcode  EQU         $4D75                   * compare for RTS
00000000                           193              
00000000                           194  *-------------------------------------------------------------------------------
00000000                           195  *           PROGRAM CODE
00000000                           196  *-------------------------------------------------------------------------------
00001000                           197              ORG         $1000                   * program origin
00001000                           198              
00001000  2E7C 00A00000            199  prgm_start  MOVEA.L     #stk_ptr,SP             * load stack pointer
00001006  4EB9 000025DA            200              JSR         display                 * display program header
0000100C  103C 0001                201  usr_prmpt1  MOVE.B      #tsk1,D0                * load task
00001010  43F9 00002AE0            202              LEA         prompt1,A1              * get address of string
00001016  3239 00002B12            203              MOVE.W      p_len1,D1               * get length of string
0000101C  4E4F                     204              TRAP        #15                     * display prompt1
0000101E  103C 0002                205  usr_inpt1   MOVE.B      #tsk2,D0                * load task
00001022  43F9 0000266C            206              LEA         s_addr,A1               * store string from user
00001028  323C 0008                207              MOVE.W      #(e_addr-s_addr),D1     * length of user input
0000102C  4E4F                     208              TRAP        #15                     * get user input
0000102E  13C1 00002C46            209              MOVE.B      D1,s_a_l                * copy length to storage
00001034                           210  
00001034  7E00                     211              MOVE.L      #empty,D7               * zero register
00001036  47F9 0000266C            212              LEA         s_addr,A3               * load starting address
0000103C  4EB9 000022EC            213              JSR         convert                 * subroutine "cnvrt"
00001042  2847                     214              MOVE.L      D7,A4                   * load register with hex s_addr
00001044                           215  
00001044  4EB9 000022A4            216              JSR         isValid                 * subroutine "isValid"
0000104A  BEBC 00000000            217              CMP.L       #empty,D7               * compare flag
00001050  66BA                     218              BNE         usr_prmpt1              * branch to top (usr_prmpt1)
00001052                           219  
00001052  103C 0001                220  usr_prmpt2  MOVE.B      #tsk1,D0                * load task
00001056  43F9 00002B14            221              LEA         prompt2,A1              * get address of string
0000105C  3239 00002B40            222              MOVE.W      p_len2,D1               * get length of string
00001062  4E4F                     223              TRAP        #15                     * display prompt2
00001064  103C 0002                224  usr_inpt2   MOVE.B      #tsk2,D0                * load task
00001068  43F9 00002674            225              LEA         e_addr,A1               * store string from user
0000106E  123C 0008                226              MOVE.B      #(exit-e_addr),D1       * length of user input
00001072  4E4F                     227              TRAP        #15                     * get user input        
00001074  13C1 00002C47            228              MOVE.B      D1,e_a_l                * load length to storage
0000107A                           229  
0000107A  7E00                     230              MOVE.L      #empty,D7               * zero register
0000107C  47F9 00002674            231              LEA         e_addr,A3               * load ending address
00001082  4EB9 000022EC            232              JSR         convert                 * subroutine "cnvrt"
00001088  2A47                     233              MOVEA.L     D7,A5                   * load register with hex e_addr
0000108A                           234  
0000108A  4EB9 000022A4            235              JSR         isValid                 * subroutine "isValid"
00001090  BEBC 00000000            236              CMP.L       #empty,D7               * compare flag
00001096  66BA                     237              BNE         usr_prmpt2              * branch to top 'usr_prmpt2'
00001098                           238  
00001098  B9CD                     239  fst_chk     CMPA.L      A5,A4                   * compare starting and ending addresses
0000109A  6D00 0016                240              BLT         lst_chk                 * branch to last check
0000109E  103C 0001                241              MOVE.B      #tsk1,D0                * load task number
000010A2  43F9 00002BF2            242              LEA         error4,A1               * get address of string
000010A8  323C 2C44                243              MOVE.W      #e_len4,D1              * get length of string
000010AC  4E4F                     244              TRAP        #15                     * display error message
000010AE  4EF8 1052                245              JMP         usr_prmpt2              * jump to top 'usr_prmpt2'
000010B2  2C4D                     246  lst_chk     MOVEA.L     A5,A6                   * load address
000010B4  558E                     247              SUBQ.L      #$2,A6                  * subtract a word from ending address
000010B6  BDCC                     248              CMPA.L      A4,A6                   * compare starting and ending addresses
000010B8  6C00 0016                249              BGE         sub_main                * branch to 'main program
000010BC  103C 0001                250              MOVE.B      #tsk1,D0                * load task number
000010C0  43F9 00002BCC            251              LEA         error3,A1               * get address of string
000010C6  323C 2BF0                252              MOVE.W      #e_len3,D1              * get length of string
000010CA  4E4F                     253              TRAP        #15                     * display error messasge
000010CC  4EF8 100C                254              JMP         usr_prmpt1              * jump to top 'usr_prpmt1'
000010D0                           255  
000010D0                           256  *-------------------------------------------------------------------------------
000010D0                           257  *           REGISTER CONDITIONS AFTER USER INPUT AND ERROR CHECKING
000010D0                           258  *           A4 - starting address
000010D0                           259  *           A5 - ending address
000010D0                           260  *-------------------------------------------------------------------------------
000010D0  4EB9 00002582            261  sub_main    JSR         clearReg                * clear all registers (except for A4 and A5)
000010D6  7000                     262              MOVE.L      #empty,D0               * clear register
000010D8  13FC 0000 0000267F       263  main        MOVE.B      #good,flag              * reset flag
000010E0  5239 0000267E            264              ADDQ.B      #increment,p_count      * increment line counter
000010E6  0C39 000F 0000267E       265              CMPI.B      #$F,p_count             * check if line max has been reached
000010EE  6700 0008                266              BEq         enter_                  * branch to label
000010F2  4EF9 00001118            267              JMP         ini_buffers             * initialize buffers
000010F8  103C 0001                268  enter_      MOVE.B      #tsk1,D0                * load task
000010FC  43F9 00002AC0            269              LEA         v_msg7,A1               * get address of string
00001102  3239 00002ADE            270              MOVE.W      v_len7,D1               * get length of string
00001108  4E4F                     271              TRAP        #15                     * display message
0000110A  103C 0002                272              MOVE.B      #tsk2,D0                * load task
0000110E  4E4F                     273              TRAP        #15                     * wait for key
00001110  13FC 0000 0000267E       274              MOVE.B      #reset,p_count          * clear counter
00001118                           275  
00001118  4EB9 000024AC            276  ini_buffers JSR         setBuffers              * initialize buffers
0000111E                           277              
0000111E                           278              * A2 points to next position in good_buffer
0000111E  4EB9 000025B2            279              JSR         clearSome               * clear all registers except for D0, A2, A4, A5 
00001124  41F9 00002680            280              LEA         bin_pattern,A0          * load register
0000112A  43F9 000026A0            281              LEA         bin_storage,A1          * load register
00001130  13FC 0000 0000267D       282              MOVE.B      #reset,counter          * reset counter
00001138  0C39 0002 0000267D       283  gen_type    CMPI.B      #loop,counter           * check loop sentinel value
00001140  6C00 0034                284              BGE         op_type                 * exit loop?
00001144  E158                     285              ROL.W       #8,D0                   * rotate MSBs to LSBs
00001146  3200                     286              MOVE.W      D0,D1                   * operate only on D1
00001148                           287              
00001148  0241 00F0                288              ANDI.W      #mask_left,D1           * isolate left nibble
0000114C  E859                     289              ROR.W       #4,D1                   * shift to LSB
0000114E  D241                     290              ADD.W       D1,D1                   * double value
00001150  D0C1                     291              ADD.W       D1,A0                   * shift pointer to pattern
00001152  32D0                     292              MOVE.W      (A0),(A1)+              * copy word to storage
00001154  41F9 00002680            293              LEA         bin_pattern,A0          * restore pattern pointer
0000115A  3200                     294              MOVE.W      D0,D1                   * restore register
0000115C                           295              
0000115C  0241 000F                296              ANDI.W      #mask_right,D1          * isolate right nibble
00001160  D241                     297              ADD.W       D1,D1                   * double value
00001162  D0C1                     298              ADD.W       D1,A0                   * shift pointer to pattern
00001164  32D0                     299              MOVE.W      (A0),(A1)+              * copy word to storage
00001166  41F9 00002680            300              LEA         bin_pattern,A0          * restore pattern pointer
0000116C  5239 0000267D            301              ADDQ.B      #increment,counter      * increment counter
00001172  4EF8 1138                302              JMP         gen_type                * jump to top of loop
00001176                           303              
00001176                           304              * D0 contains word from memory
00001176                           305              * 'storage' contains binary for word
00001176  43F9 000026A0            306  op_type     LEA         bin_storage,A1          * load register with addres of bin_storage
0000117C  3419                     307              MOVE.W      (A1)+,D2                * move first 4 bits to D2
0000117E  B47C 0000                308              CMP.W       #$0000,D2               * nibble 0: ADDI, ANDI, CMPI, EORI, ORI, SUBI
00001182  6700 0292                309              BEq         immsr                   * "immediate" branch
00001186  B47C 0001                310              CMP.W       #$0001,D2               * nibble 1: MOVE.B
0000118A  6700 0B56                311              BEq         moveb_                  * "move type byte" branch
0000118E  B47C 0010                312              CMP.W       #$0010,D2               * nibble 2: MOVE.L, MOVEA.L
00001192  6700 0B68                313              BEq         movel_                  * "move type long" branch
00001196  B47C 0011                314              CMP.W       #$0011,D2               * nibble 3: MOVE.W, MOVEA.W
0000119A  6700 0BA2                315              BEq         movew_                  * "move type word" branch
0000119E  B47C 0100                316              CMP.W       #$0100,D2               * nibble 4: CLR, JMP, JSR, RTS, NEG, NOP, LEA, SWAP, MOVEM
000011A2  6700 0D6E                317              BEq         specl_                  * "special codes" branch
000011A6  B47C 0101                318              CMP.W       #$0101,D2               * nibble 5: BAD
000011AA  6700 0046                319              BEq         setBad                  * set bad flag
000011AE  B47C 0110                320              CMP.W       #$0110,D2               * nibble 6: BSR, BRA, Bcc (Branch Condition Code)
000011B2  6700 041E                321              BEq         brnch_                  * "branch / BRA, BEq, BGT, BGE, BLT, BLE, BNE" branch
000011B6  B47C 0111                322              CMP.W       #$0111,D2               * nibble 7: BAD
000011BA  6700 0036                323              BEq         setBad                  * set bad flag
000011BE  B47C 1000                324              CMP.W       #$1000,D2               * nibble 8: OR
000011C2  6700 04E4                325              BEq         or_                     * "or" branch
000011C6  B47C 1001                326              CMP.W       #$1001,D2               * nibble 9: SUB, SUBA
000011CA  6700 0818                327              BEq         sub_                    * "subtraction" branch
000011CE  B47C 1011                328              CMP.W       #$1011,D2               * nibble B: CMP, CMPA, EOR
000011D2  6700 098C                329              BEq         cmpsr                   * "compare and exclusive-or" branch
000011D6  B47C 1100                330              CMP.W       #$1100,D2               * nibble C: AND, EXG
000011DA  6700 05D6                331              BEq         ane_                    * "and / exg" branch
000011DE  B47C 1101                332              CMP.W       #$1101,D2               * nibble D: ADD, ADDA
000011E2  6700 00C0                333              BEq         add_                    * "add" branch
000011E6  B47C 1110                334              CMP.W       #$1110,D2               * nibble E: ASR, ASL, LSR, LSL, ROL, ROR
000011EA  6700 0B94                335              BEq         manip_                  * "left-right manipulation" branch
000011EE  B47C 1111                336              CMP.W       #$1111,D2               * nibble F: RESERVED (thus bad)
000011F2                           337  
000011F2  13FC 00FF 0000267F       338  setBad      MOVE.B      #bad,flag               * set flag to bad
000011FA  4EF9 00001200            339              JMP         prnttoscrn              * jump to printer
00001200                           340              
00001200  7000                     341  prnttoscrn  MOVE.L      #empty,D0               * clear register
00001202  14FC 000A                342              MOVE.B      #newline,(A2)+          * add newline to buffer
00001206  14FC 000D                343              MOVE.B      #return,(A2)+           * add carriage return to buffer
0000120A  0C39 0000 0000267F       344              CMP.B       #good,flag              * check flag state
00001212  6700 000E                345              BEq         prnt_good               * display good buffer
00001216  43F9 0000279A            346              LEA         bad_buffer,A1           * load address of bad buffer
0000121C  4EF9 00001228            347              JMP         printer                 * goto printer
00001222  43F9 00002748            348  prnt_good   LEA         good_buffer,A1          * load address of good buffer
00001228  103C 0000                349  printer     MOVE.B      #tsk0,D0                * load task
0000122C  323C 0080                350              MOVE.W      #$80,D1                 * load length of storage
00001230  4E4F                     351              TRAP        #15                     * display storage
00001232                           352              
00001232  4EB9 00002582            353              JSR         clearReg                * clear registers
00001238  BBCC                     354              CMP.L       A4,A5                   * compare current and ending addresses
0000123A  6F00 002A                355              BLE         usr_prmpt3              * branch to label
0000123E  4EF8 10D8                356              JMP         main                    * return to top
00001242                           357              
00001242  103C 0001                358  fnl_msg1    MOVE.B      #tsk1,D0                * load task
00001246  43F9 00002A7C            359              LEA         v_msg5,A1               * load address of string
0000124C  3239 00002A94            360              MOVE.W      v_len5,D1               * get length of string
00001252  4E4F                     361              TRAP        #15                     * display final message 1
00001254  103C 0001                362  fnl_msg2    MOVE.B      #tsk1,D0    `           * load task
00001258  43F9 00002A96            363              LEA         v_msg6,A1               * load address of string
0000125E  3239 00002ABE            364              MOVE.W      v_len6,D1               * get length of string
00001264  4E4F                     365              TRAP        #15                     * display final message 1
00001266  103C 0000                366  usr_prmpt3  MOVE.B      #tsk0,D0                * load task
0000126A  43F9 00002B42            367              LEA         prompt3,A1              * load address of string
00001270  3239 00002B64            368              MOVE.W      p_len3,D1               * get length of string
00001276  4E4F                     369              TRAP        #15                     * display prompt 3
00001278  103C 0002                370  usr_inpt3   MOVE.B      #tsk2,D0                * load task
0000127C  43F9 0000267C            371              LEA         exit,A1                 * store input from user
00001282  323C 0001                372              MOVE.W      #(counter-exit),D1      * length of user input
00001286  4E4F                     373              TRAP        #15                     * get user input
00001288                           374              
00001288  0C39 0059 0000267C       375              CMPI.B      #yes1,exit              * check if user entered yes
00001290  6700 FD7A                376              BEq         usr_prmpt1              * branch to beginning
00001294  0C39 0079 0000267C       377              CMPI.B      #yes2,exit              * check if user entered yes
0000129C  6700 FD6E                378              BEq         usr_prmpt1              * branch to beginning
000012A0                           379              
000012A0  4E72 2700                380  prgm_done   STOP        #$2700                  * return to program main
000012A4                           381              
000012A4                           382  ********************************************************************************    
000012A4                           383  *                                                                              *
000012A4                           384  *                            OP-CODE BRANCHES                                  *
000012A4                           385  *                                                                              *
000012A4                           386  ********************************************************************************
000012A4                           387  ********************************************************************************
000012A4                           388  * Branch Description: ADD / ADDA - Neal
000012A4                           389  ********************************************************************************
000012A4  41F9 000026C0            390  add_        LEA         math_stor,A0            * load address of 'add' container
000012AA  24D0                     391              MOVE.L      (A0),(A2)+              * copy word to buffer
000012AC  2411                     392              MOVE.L      (A1),D2                 * move bits from storage to D2
000012AE  C4BC 000FFF00            393              AND.L       #arith_mask1,D2         * isolate opmode
000012B4  E08A                     394              LSR.L       #8,D2                   * shift opcode bits to right
000012B6  7600                     395              MOVE.L      #empty,D3               * clear D3 register     
000012B8  41F9 00002680            396              LEA         bin_pattern,A0          * re-initialize A0 to point to begining of patterns
000012BE  4EB9 000023A6            397              JSR         bin_to_dec              * convert opcode to decimal
000012C4  B63C 0003                398              CMP.B       #$3,D3                  * if decimal is == to 3, then instruction is ADDA
000012C8  6700 00DE                399              BEQ         adda_ea_dn              * Yes, it is 3, branch to ADDA
000012CC  B63C 0007                400              CMP.B       #$7,D3                  * if decimal is == to 7, then instruction is also ADDA
000012D0  6700 00D6                401              BEQ         adda_ea_dn              * Yes, it is 3, branch to ADDA
000012D4  B63C 0004                402              CMP.B       #$4,D3                  * if decimal is >= 4, then instruction is ADD Dn+<ea>
000012D8  6C00 000A                403              BGE         add_dn_ea               * yes, it is >= 4
000012DC  B63C 0004                404              CMP.B       #$4,D3                  * if decimal is < 4, then instruction is ADD <ea>+Dn
000012E0  6D00 0062                405              BLT         add_ea_dn               * yes, it is < 4
000012E4                           406  
000012E4                           407  
000012E4  C4BC 000000FF            408  add_dn_ea   AND.L       #arith_mask3,D2         * isolate the right 2 bits of opmode to determine if it's a L,W,or B
000012EA  7600                     409              MOVE.L      #empty,D3               * clear D3 register     
000012EC  41F9 00002680            410              LEA         bin_pattern,A0          * re-initialize A0 to point to begining of patterns
000012F2  4EB9 000023A6            411              JSR         bin_to_dec              * subroutine to convert value in D2 to decimal
000012F8  4EB9 00002276            412              JSR         appends                 * append 'L', 'W', or 'B' to buffer
000012FE  2411                     413              MOVE.L      (A1),D2                 * move bits from storage to D2
00001300  C4BC FFF00000            414              AND.L       #arith_mask2,D2         * mask to isolate register
00001306  E19A                     415              ROL.L       #8,D2                   * push bits to correct position
00001308  E99A                     416              ROL.L       #4,D2                   * push it a little more
0000130A  7600                     417              MOVE.L      #empty,D3               * clear D3
0000130C  41F9 00002680            418              LEA         bin_pattern,A0          * re-initalize A0 to point to begining of patterns
00001312  4EB9 000023A6            419              JSR         bin_to_dec              * convert value in D2 to decimal
00001318  14FC 0020                420              MOVE.B      #space,(A2)+            * add a space to buffer
0000131C  14FC 0044                421              MOVE.B      #$44,(A2)+              * add a 'D' to buffer
00001320  0603 0030                422              ADDI.B      #$30,D3                 * determine data register value in ASCII
00001324  14C3                     423              MOVE.B      D3,(A2)+                * push data register number into buffer
00001326  14FC 002C                424              MOVE.B      #comma,(A2)+            * add a ',' to buffer
0000132A  43F9 000026A0            425              LEA         bin_storage,A1          * re-initalize A1 to point to begining of storage
00001330  2419                     426              MOVE.L      (A1)+,D2                * store left 8 bits into D2
00001332  2419                     427              MOVE.L      (A1)+,D2                * store right most 8 bits into D2
00001334  C4BC 00FFFFFF            428              AND.L       #arith_mask4,D2         * mask to isolate last 6 bits
0000133A  4EB9 000020BA            429              JSR         genEA                   * goto subroutine 'genEA'
00001340  4EF8 1200                430              JMP         prnttoscrn              * print the buffer
00001344                           431  
00001344  C4BC 000000FF            432  add_ea_dn   AND.L       #arith_mask3,D2         * isolate the right 2 bits of opmode to determine if it's a L,W,or B
0000134A  7600                     433              MOVE.L      #empty,D3               * clear D3 register     
0000134C  41F9 00002680            434              LEA         bin_pattern,A0          * re-initialize A0 to point to begining of patterns
00001352  4EB9 000023A6            435              JSR         bin_to_dec              * subroutine to convert value in D2 to decimal
00001358  4EB9 00002276            436              JSR         appends                 * append 'L', 'W', or 'B' to buffer 
0000135E  14FC 0020                437              MOVE.B      #space,(A2)+            * add a space to buffer
00001362  43F9 000026A0            438              LEA         bin_storage,A1          * re-initalize A1 to point to begining of storage
00001368  2419                     439              MOVE.L      (A1)+,D2                * store left 8 bits into D2
0000136A  2419                     440              MOVE.L      (A1)+,D2                * store right most 8 bits into D2
0000136C  C4BC 00FFFFFF            441              AND.L       #arith_mask4,D2         * mask to isolate last 6 bits
00001372  4EB9 000020BA            442              JSR         genEA                   * pass control to effective address
00001378  14FC 002C                443              MOVE.B      #comma,(A2)+            * add a ',' to buffer
0000137C  14FC 0044                444              MOVE.B      #$44,(A2)+              * add a 'D' to buffer
00001380  43F9 000026A0            445              LEA         bin_storage,A1          * re-initalize A1 to point to begining of binary opcode
00001386  2411                     446              MOVE.L      (A1),D2                 * move first 8 bits into D2
00001388  C4BC 0000FFF0            447              AND.L       #arith_mask5,D2         * mask to isolate the register value bits
0000138E  E88A                     448              LSR.L       #4,D2                   * shift bits in D2 to the right
00001390  7600                     449              MOVE.L      #empty,D3               * clear D3
00001392  41F9 00002680            450              LEA         bin_pattern,A0          * re-initalize A0 to point to begining of patterns
00001398  4EB9 000023A6            451              JSR         bin_to_dec              * convert value in D2 to decimal, decimal result stored in D3
0000139E  0603 0030                452              ADDI.B      #$30,D3                 * determine data register value in ASCII
000013A2  14C3                     453              MOVE.B      D3,(A2)+                * push data register number into buffer
000013A4  4EF8 1200                454              JMP         prnttoscrn              * print the buffer
000013A8                           455  
000013A8  41F9 000026C0            456  adda_ea_dn  LEA         math_stor,A0            * load address of 'add' container
000013AE  5888                     457              ADDA.L      #4,A0                   * add displacement to fetch 'ADDA'
000013B0  24D0                     458              MOVE.L      (A0),(A2)+              * copy word to buffer
000013B2  B47C 0011                459              CMP.W       #$0011,D2               * if bits == 11, it's of size W
000013B6  6700 0052                460              BEQ         adda_s_w                * branch to append '.W'
000013BA  B47C 0111                461              CMP.W       #$0111,D2               * if bits == 111, it's of size L
000013BE  6700 0050                462              BEQ         adda_s_l                * branch to append '.L'
000013C2  14FC 0020                463  cont_adda   MOVE.B      #space,(A2)+            * add a space to buffer
000013C6  43F9 000026A0            464              LEA         bin_storage,A1          * re-initalize A1 to point to begining of storage
000013CC  2419                     465              MOVE.L      (A1)+,D2                * store left 8 bits into D2
000013CE  2419                     466              MOVE.L      (A1)+,D2                * store right most 8 bits into D2
000013D0  C4BC 00FFFFFF            467              AND.L       #arith_mask4,D2         * mask to isolate last 6 bits
000013D6  4EB9 000020BA            468              JSR         genEA                   * pass control to effective address
000013DC  14FC 002C                469              MOVE.B      #comma,(A2)+            * add a ',' to buffer
000013E0  14FC 0041                470              MOVE.B      #$41,(A2)+              * add a 'A' to buffer
000013E4  43F9 000026A0            471              LEA         bin_storage,A1          * re-initalize A1 to point to begining of binary opcode
000013EA  2411                     472              MOVE.L      (A1),D2                 * move first 8 bits into D2
000013EC  C4BC 0000FFF0            473              AND.L       #arith_mask5,D2         * mask to isolate the register value bits
000013F2  E88A                     474              LSR.L       #4,D2                   * shift bits in D2 to the right
000013F4  7600                     475              MOVE.L      #empty,D3               * clear D3
000013F6  41F9 00002680            476              LEA         bin_pattern,A0          * re-initalize A0 to point to begining of patterns
000013FC  4EB9 000023A6            477              JSR         bin_to_dec              * convert value in D2 to decimal, decimal result stored in D3
00001402  0603 0030                478              ADDI.B      #$30,D3                 * determine data register value in ASCII
00001406  14C3                     479              MOVE.B      D3,(A2)+                * push data register number into buffer
00001408  4E75                     480              RTS                                 * JUST TO TEST IF IT WILL PRINT OUT THE BUFFER
0000140A                           481  
0000140A  34FC 2E57                482  adda_s_w    MOVE.W      #$2E57,(A2)+            * append '.W' to buffer
0000140E  60B2                     483              BRA         cont_adda               * jump to continue decoding
00001410                           484  
00001410  34FC 2E4C                485  adda_s_l    MOVE.W      #$2E4C,(A2)+            * append '.L' to buffer
00001414  60AC                     486              BRA         cont_adda               * jump to continue decoding
00001416                           487  
00001416                           488  
00001416                           489  ********************************************************************************
00001416                           490  * Branch Description: IMMEDIATES - Neal
00001416                           491  ********************************************************************************
00001416  43F9 000026A0            492  immsr       LEA         bin_storage,A1          * re-initalize A1 to point to begining of binary opcode
0000141C  2419                     493              MOVE.L      (A1)+,D2                * move first 8 bits into D2
0000141E  B47C 0110                494              CMP.W       #addi_opcode,D2         * is opcode an addi
00001422  6700 0038                495              BEQ         addi_                   * yes, branch
00001426  B4BC 00000010            496              CMP.L       #andi_opcode,D2         * is opcode an andi
0000142C  6700 0046                497              BEQ         andi_                   * yes, branch
00001430  B4BC 00001100            498              CMP.L       #cmpi_opcode,D2         * is opcode a cmpi
00001436  6700 0052                499              BEQ         cmpi_                   * yes, branch
0000143A  B4BC 00001010            500              CMP.L       #eori_opcode,D2         * is opcode an eori
00001440  6700 0060                501              BEQ         eori_                   * yes, branch
00001444  B4BC 00000000            502              CMP.L       #ori_opcode,D2          * is opcode an ori
0000144A  6700 006E                503              BEQ         ori_                    * yes, branch
0000144E  B4BC 00000100            504              CMP.L       #subi_opcode,D2         * is opcode a subi
00001454  6700 0080                505              BEQ         subi_                   * yes, branch
00001458  4EF8 11F2                506              JMP         setBad                  * IT IS NEITHER OF THESE, BAD
0000145C                           507  
0000145C  41F9 000026C0            508  addi_       LEA         math_stor,A0            * load address of 'math_stor' container
00001462  5088                     509              ADDA.L      #8,A0                   * add displacement to fetch 'ADDI'
00001464  24D0                     510              MOVE.L      (A0),(A2)+              * copy 'ADDI' to buffer
00001466  2411                     511              MOVE.L      (A1),D2                 * move next 8 bits into D2
00001468  C4BC FF000000            512              AND.L       #imm_mask1,D2           * isolate the size bits
0000146E  4EF9 000014F2            513              JMP         immsize                 * append the size
00001474                           514  
00001474  41F9 000026D8            515  andi_       LEA         immi_stor,A0            * load address of 'math_stor' container
0000147A  24D0                     516              MOVE.L      (A0),(A2)+              * copy 'ANDI' to buffer
0000147C  2411                     517              MOVE.L      (A1),D2                 * move next 8 bits into D2
0000147E  C4BC FF000000            518              AND.L       #imm_mask1,D2           * isolate the size bits
00001484  4EF9 000014F2            519              JMP         immsize                 * append the size
0000148A                           520  
0000148A  41F9 000026D8            521  cmpi_       LEA         immi_stor,A0            * load address of 'math_stor' container
00001490  5888                     522              ADDA.L      #4,A0                   * add displacement to fetch 'ADDI'
00001492  24D0                     523              MOVE.L      (A0),(A2)+              * copy 'ANDI' to buffer
00001494  2411                     524              MOVE.L      (A1),D2                 * move next 8 bits into D2
00001496  C4BC FF000000            525              AND.L       #imm_mask1,D2           * isolate the size bits
0000149C  4EF9 000014F2            526              JMP         immsize                 * append the size
000014A2                           527  
000014A2  41F9 000026D8            528  eori_       LEA         immi_stor,A0            * load address of 'math_stor' container
000014A8  5088                     529              ADDA.L      #8,A0                   * add displacement to fetch 'ADDI'
000014AA  24D0                     530              MOVE.L      (A0),(A2)+              * copy 'ANDI' to buffer
000014AC  2411                     531              MOVE.L      (A1),D2                 * move next 8 bits into D2
000014AE  C4BC FF000000            532              AND.L       #imm_mask1,D2           * isolate the size bits
000014B4  4EF9 000014F2            533              JMP         immsize                 * append the size
000014BA                           534  
000014BA  41F9 000026D8            535  ori_        LEA         immi_stor,A0            * load address of 'math_stor' container
000014C0  D1FC 0000000C            536              ADDA.L      #12,A0                  * add displacement to fetch 'ADDI'
000014C6  24D0                     537              MOVE.L      (A0),(A2)+              * copy 'ANDI' to buffer
000014C8  2411                     538              MOVE.L      (A1),D2                 * move next 8 bits into D2
000014CA  C4BC FF000000            539              AND.L       #imm_mask1,D2           * isolate the size bits
000014D0  4EF9 000014F2            540              JMP         immsize                 * append the size
000014D6                           541  
000014D6  41F9 000026C0            542  subi_       LEA         math_stor,A0            * load address of 'math_stor' container
000014DC  D1FC 00000014            543              ADDA.L      #20,A0                  * add displacement to fetch 'ADDI'
000014E2  24D0                     544              MOVE.L      (A0),(A2)+              * copy 'ANDI' to buffer
000014E4  2411                     545              MOVE.L      (A1),D2                 * move next 8 bits into D2
000014E6  C4BC FF000000            546              AND.L       #imm_mask1,D2           * isolate the size bits
000014EC  4EF9 000014F2            547              JMP         immsize                 * append the size       
000014F2                           548              
000014F2                           549  
000014F2  B4BC 00000000            550  immsize     CMP.L       #$00000000,D2           * mask to check if size is byte
000014F8  6700 001A                551              BEQ         imm_byte                * it is byte, branch
000014FC  B4BC 01000000            552              CMP.L       #$01000000,D2           * mask to check if size is word
00001502  6700 002E                553              BEQ         imm_word                * it is word, branch
00001506  B4BC 10000000            554              CMP.L       #$10000000,D2           * mask to check if size is long
0000150C  6700 0052                555              BEQ         imm_long                * it is long, branch
00001510  4EF8 11F2                556              JMP         setBad                  * it's none of these, ERROR!
00001514                           557  
00001514  34FC 2E42                558  imm_byte    MOVE.W      #$2E42,(A2)+            * append '.B' to buffer
00001518  24FC 2023241A            559              MOVE.L      #$2023241A,(A2)+        * append space, dollar sign, pound
0000151E  301C                     560              MOVE.W      (A4)+,D0                * move the <data> MUST CHANGE TO (A4)+,D0
00001520  C0BC 000000FF            561              AND.L       #hToAMask_2,D0          * isolate right byte of the word
00001526  4EB9 0000234E            562              JSR         hexToA                  * convert byte to ascii and append to printbuff
0000152C  4EF9 000015AC            563              JMP         resumeimm               * jump to resume until done
00001532                           564              
00001532                           565              
00001532  34FC 2E57                566  imm_word    MOVE.W      #$2E57,(A2)+            * append '.W' to buffer
00001536  24FC 2023241A            567              MOVE.L      #$2023241A,(A2)+        * append space, dollar sign, pound
0000153C  3014                     568              MOVE.W      (A4),D0                 * move the <data> MUST CHANGE TO (A4),D0
0000153E  C0BC 0000FF00            569              AND.L       #hToAMask_1,D0          * isolate left byte of word
00001544  E088                     570              LSR.L       #8,D0                   * shift byte to least sig digit
00001546  4EB9 0000234E            571              JSR         hexToA                  * convert values to ascii for buffer
0000154C  301C                     572              MOVE.W      (A4)+,D0                * move the <data> MUST CHANGE TO (A4)+,D0
0000154E  C0BC 000000FF            573              AND.L       #hToAMask_2,D0          * isolate left byte of word
00001554  4EB9 0000234E            574              JSR         hexToA                  * convert values to ascii for buffer
0000155A  4EF9 000015AC            575              JMP         resumeimm               * jump to resume until done
00001560                           576  
00001560  34FC 2E4C                577  imm_long    MOVE.W      #$2E4C,(A2)+            * append '.L' to buffer
00001564  24FC 2023241A            578              MOVE.L      #$2023241A,(A2)+        * append space, dollar sign, pound
0000156A  3014                     579              MOVE.W      (A4),D0                 * move the <data> MUST CHANGE TO (A4),D0
0000156C  C0BC 0000FF00            580              AND.L       #hToAMask_1,D0          * isolate left byte of word
00001572  E088                     581              LSR.L       #8,D0                   * shift byte to least sig digit
00001574  4EB9 0000234E            582              JSR         hexToA                  * convert values to ascii for buffer
0000157A  301C                     583              MOVE.W      (A4)+,D0                * move the <data> MUST CHANGE TO (A4)+,D0
0000157C  C0BC 000000FF            584              AND.L       #hToAMask_2,D0          * isolate left byte of word
00001582  4EB9 0000234E            585              JSR         hexToA                  * convert values to ascii for buffer
00001588  3014                     586              MOVE.W      (A4),D0                 * move the <data> MUST CHANGE TO (A4),D0
0000158A  C0BC 0000FF00            587              AND.L       #hToAMask_1,D0          * isolate left byte of word
00001590  E088                     588              LSR.L       #8,D0                   * shift byte to least sig digit
00001592  4EB9 0000234E            589              JSR         hexToA                  * convert values to ascii for buffer
00001598  301C                     590              MOVE.W      (A4)+,D0                * move the <data> MUST CHANGE TO (A4)+,D0
0000159A  C0BC 000000FF            591              AND.L       #hToAMask_2,D0          * isolate left byte of word
000015A0  4EB9 0000234E            592              JSR         hexToA                  * convert values to ascii for buffer
000015A6  4EF9 000015AC            593              JMP         resumeimm               * jump to resume until done
000015AC                           594  
000015AC  14FC 002C                595  resumeimm   MOVE.B      #comma,(A2)+            * add a ',' to buffer
000015B0  2411                     596              MOVE.L      (A1),D2                 * move next 8 bits into D2
000015B2  C4BC 00FFFFFF            597              AND.L       #imm_mask2,D2           * isolate last 6 bits
000015B8  43F9 000026A0            598              LEA         bin_storage,A1          * re-initalize A1 to point to begining of storage
000015BE  2419                     599              MOVE.L      (A1)+,D2                * store left 8 bits into D2
000015C0  2419                     600              MOVE.L      (A1)+,D2                * store right most 8 bits into D2
000015C2  C4BC 00FFFFFF            601              AND.L       #arith_mask4,D2         * mask to isolate last 6 bits
000015C8  4EB9 000020BA            602              JSR         genEA                   * generate EA content
000015CE  4EF8 1200                603              JMP         prnttoscrn              * go print the buffer
000015D2                           604              
000015D2                           605  
000015D2                           606  ********************************************************************************
000015D2                           607  * Branch Description: BSR - Neal
000015D2                           608  ********************************************************************************
000015D2  41F9 00002718            609  brnch_      LEA         brch_stor,A0            * load address of 'BSR' container
000015D8  24D0                     610              MOVE.L      (A0),(A2)+              * copy 'BSR' to buffer
000015DA  3419                     611              MOVE.W      (A1)+,D2                * move bits from storage to D2
000015DC  B47C 0001                612              CMP.W       #$0001,D2               * compare next 4 bits to verify it is BSR
000015E0  6700 0006                613              BEQ         branchsr_               * it sure is, continue
000015E4  4EF8 11F2                614              JMP         setBad                  * no, it's not, set bad flag
000015E8                           615              
000015E8  2411                     616  branchsr_   MOVE.L      (A1),D2                 * move last 8 bits from storage
000015EA  C4BC FFFF0000            617              AND.L       #bsr_mask1,D2           * isolate left 4 bits
000015F0  E08A                     618              LSR.L       #8,D2                   * shift towards LSB
000015F2  E08A                     619              LSR.L       #8,D2                   * shift towards LSB
000015F4  7600                     620              MOVE.L      #empty,D3               * clear D3 register
000015F6  41F9 00002680            621              LEA         bin_pattern,A0          * re-initalize A0 to point to begining of patterns
000015FC  4EB9 000023A6            622              JSR         bin_to_dec              * convert value in D2 to hex
00001602  1C03                     623              MOVE.B      D3,D6                   * Move hex value into D6 
00001604  E98E                     624              LSL.L       #4,D6                   * Shift hex in D6 to left once
00001606  2411                     625              MOVE.L      (A1),D2                 * move last 8 bits from storage
00001608  C4BC 0000FFFF            626              AND.L       #bsr_mask2,D2           * isolate left right bits
0000160E  7600                     627              MOVE.L      #empty,D3               * clear D3 register
00001610  41F9 00002680            628              LEA         bin_pattern,A0          * re-initalize A0 to point to begining of patterns
00001616  4EB9 000023A6            629              JSR         bin_to_dec              * convert value in D2 to hex
0000161C  8C03                     630              OR.B        D3,D6                   * OR hex digit in D3 with D6
0000161E  24FC 2023241A            631              MOVE.L      #$2023241A,(A2)+        * append space, dollar sign, pound
00001624  BC3C 0000                632              CMP.B       #$00,D6                 * check to see if 16 bit displace
00001628  6700 001C                633              BEQ         bsr_16                  * yes it is, branch
0000162C  BC3C 00FF                634              CMP.B       #$FF,D6                 * check to see if 32 bit displace
00001630  6700 0036                635              BEQ         bsr_32                  * yes it is, branch
00001634  1006                     636              MOVE.B      D6,D0                   * move 8-bit displacement to D0
00001636  C0BC 000000FF            637              AND.L       #hToAMask_2,D0          * isolate only the right most byte
0000163C  4EB9 0000234E            638              JSR         hexToA                  * convert byte to ascii
00001642  4EF8 1200                639              JMP         prnttoscrn              * print good buffer
00001646                           640                          
00001646  3014                     641  bsr_16      MOVE.W      (A4),D0                 * move the <data> MUST CHANGE TO (A4),D0
00001648  C0BC 0000FF00            642              AND.L       #hToAMask_1,D0          * isolate left byte of word
0000164E  E088                     643              LSR.L       #8,D0                   * shift byte to least sig digit
00001650  4EB9 0000234E            644              JSR         hexToA                  * convert hex values to ascii for buffer
00001656  301C                     645              MOVE.W      (A4)+,D0                * move the <data> MUST CHANGE TO (A4)+,D0
00001658  C0BC 000000FF            646              AND.L       #hToAMask_2,D0          * isolate right  byte of word
0000165E  4EB9 0000234E            647              JSR         hexToA                  * convert hex values to ascii for buffer
00001664  4EF8 1200                648              JMP         prnttoscrn              * print good buffer
00001668                           649  
00001668  3014                     650  bsr_32      MOVE.W      (A4),D0                 * move the <data> MUST CHANGE TO (A4),D0
0000166A  C0BC 0000FF00            651              AND.L       #hToAMask_1,D0          * isolate left byte of word
00001670  E088                     652              LSR.L       #8,D0                   * shift byte to least sig digit
00001672  4EB9 0000234E            653              JSR         hexToA                  * convert hex values to ascii for buffer
00001678  301C                     654              MOVE.W      (A4)+,D0                * move the <data> MUST CHANGE TO (A4)+,D0
0000167A  C0BC 000000FF            655              AND.L       #hToAMask_2,D0          * isolate right  byte of word
00001680  4EB9 0000234E            656              JSR         hexToA                  * convert hex values to ascii for buffer
00001686  3014                     657              MOVE.W      (A4),D0                 * move the <data> MUST CHANGE TO (A4),D0
00001688  C0BC 0000FF00            658              AND.L       #hToAMask_1,D0          * isolate left byte of word
0000168E  E088                     659              LSR.L       #8,D0                   * shift byte to least sig digit
00001690  4EB9 0000234E            660              JSR         hexToA                  * convert hex values to ascii for buffer
00001696  301C                     661              MOVE.W      (A4)+,D0                * move the <data> MUST CHANGE TO (A4)+,D0
00001698  C0BC 000000FF            662              AND.L       #hToAMask_2,D0          * isolate right  byte of word
0000169E  4EB9 0000234E            663              JSR         hexToA                  * convert hex values to ascii for buffer
000016A4  4EF8 1200                664              JMP         prnttoscrn              * print good buffer
000016A8                           665              
000016A8                           666  ********************************************************************************
000016A8                           667  * Branch Description: OR - Neal
000016A8                           668  ********************************************************************************    
000016A8  41F9 000026E8            669  or_         LEA         lgic_stor,A0            * load address of 'or.' container
000016AE  5888                     670              ADDA.L      #4,A0                   * shift so that we are pointed to 'or.'
000016B0  24D0                     671              MOVE.L      (A0),(A2)+              * copy word to buffer
000016B2  2411                     672              MOVE.L      (A1),D2                 * move bits from storage to D2
000016B4  C4BC 000FFF00            673              AND.L       #arith_mask1,D2         * isolate opmode
000016BA  E08A                     674              LSR.L       #8,D2                   * shift opcode bits to right
000016BC  7600                     675              MOVE.L      #empty,D3               * clear D3 register     
000016BE  41F9 00002680            676              LEA         bin_pattern,A0          * re-initialize A0 to point to begining of patterns
000016C4  4EB9 000023A6            677              JSR         bin_to_dec              * convert opcode to decimal
000016CA  B63C 0003                678              CMP.B       #$3,D3                  * if decimal is <= 3 then ea before dn
000016CE  6F00 007E                679              BLE         or_ea_dn                * Branch to or <ea>,Dn
000016D2  B63C 0004                680              CMP.B       #$4,D3                  * if decimal is == 4 then dn before ea
000016D6  6700 0016                681              BEQ         or_dn_ea                * Branch to or Dn,<ea>
000016DA  B63C 0005                682              CMP.B       #$5,D3                  * if decimal is == 5 then dn before ea
000016DE  6700 000E                683              BEQ         or_dn_ea                * Branch to or Dn,<ea>
000016E2  B63C 0006                684              CMP.B       #$6,D3                  * if decimal is == 6 then dn before ea
000016E6  6700 0006                685              BEQ         or_dn_ea                * Branch to or Dn,<ea>
000016EA  4EF8 11F2                686              JMP         setBad                  * otherwise raise the bad flag
000016EE                           687  
000016EE  C4BC 000000FF            688  or_dn_ea    AND.L       #arith_mask3,D2         * isolate the right 2 bits of opmode to determine if it's a L,W,or B
000016F4  7600                     689              MOVE.L      #empty,D3               * clear D3 register     
000016F6  41F9 00002680            690              LEA         bin_pattern,A0          * re-initialize A0 to point to begining of patterns
000016FC  4EB9 000023A6            691              JSR         bin_to_dec              * subroutine to convert value in D2 to decimal
00001702  4EB9 00002276            692              JSR         appends                 * append 'L', 'W', or 'B' to buffer
00001708  2411                     693              MOVE.L      (A1),D2                 * move bits from storage to D2
0000170A  C4BC FFF00000            694              AND.L       #arith_mask2,D2         * mask to isolate register
00001710  E19A                     695              ROL.L       #8,D2                   * push bits to correct position
00001712  E99A                     696              ROL.L       #4,D2                   * push it a little more
00001714  7600                     697              MOVE.L      #empty,D3               * clear D3
00001716  41F9 00002680            698              LEA         bin_pattern,A0          * re-initalize A0 to point to begining of patterns
0000171C  4EB9 000023A6            699              JSR         bin_to_dec              * convert value in D2 to decimal
00001722  14FC 0020                700              MOVE.B      #space,(A2)+            * add a space to buffer
00001726  14FC 0044                701              MOVE.B      #$44,(A2)+              * add a 'D' to buffer
0000172A  0603 0030                702              ADDI.B      #$30,D3                 * determine data register value in ASCII
0000172E  14C3                     703              MOVE.B      D3,(A2)+                * push data register number into buffer
00001730  14FC 002C                704              MOVE.B      #comma,(A2)+            * add a ',' to buffer
00001734  43F9 000026A0            705              LEA         bin_storage,A1          * re-initalize A1 to point to begining of storage
0000173A  2419                     706              MOVE.L      (A1)+,D2                * store left 8 bits into D2
0000173C  2419                     707              MOVE.L      (A1)+,D2                * store right most 8 bits into D2
0000173E  C4BC 00FFFFFF            708              AND.L       #arith_mask4,D2         * mask to isolate last 6 bits
00001744  4EB9 000020BA            709              JSR         genEA                   * goto subroutine 'genEA'
0000174A  4EF8 1200                710              JMP         prnttoscrn              * Print out the good buffer
0000174E                           711  
0000174E  C4BC 000000FF            712  or_ea_dn    AND.L       #arith_mask3,D2         * isolate the right 2 bits of opmode to determine if it's a L,W,or B
00001754  7600                     713              MOVE.L      #empty,D3               * clear D3 register     
00001756  41F9 00002680            714              LEA         bin_pattern,A0          * re-initialize A0 to point to begining of patterns
0000175C  4EB9 000023A6            715              JSR         bin_to_dec              * subroutine to convert value in D2 to decimal
00001762  4EB9 00002276            716              JSR         appends                 * append 'L', 'W', or 'B' to buffer 
00001768  14FC 0020                717              MOVE.B      #space,(A2)+            * add a space to buffer
0000176C  43F9 000026A0            718              LEA         bin_storage,A1          * re-initalize A1 to point to begining of storage
00001772  2419                     719              MOVE.L      (A1)+,D2                * store left 8 bits into D2
00001774  2419                     720              MOVE.L      (A1)+,D2                * store right most 8 bits into D2
00001776  C4BC 00FFFFFF            721              AND.L       #arith_mask4,D2         * mask to isolate last 6 bits
0000177C  4EB9 000020BA            722              JSR         genEA                   * pass control to effective address
00001782  14FC 002C                723              MOVE.B      #comma,(A2)+            * add a ',' to buffer
00001786  14FC 0044                724              MOVE.B      #$44,(A2)+              * add a 'D' to buffer
0000178A  43F9 000026A0            725              LEA         bin_storage,A1          * re-initalize A1 to point to begining of binary opcode
00001790  2411                     726              MOVE.L      (A1),D2                 * move first 8 bits into D2
00001792  C4BC 0000FFF0            727              AND.L       #arith_mask5,D2         * mask to isolate the register value bits
00001798  E88A                     728              LSR.L       #4,D2                   * shift bits in D2 to the right
0000179A  7600                     729              MOVE.L      #empty,D3               * clear D3
0000179C  41F9 00002680            730              LEA         bin_pattern,A0          * re-initalize A0 to point to begining of patterns
000017A2  4EB9 000023A6            731              JSR         bin_to_dec              * convert value in D2 to decimal, decimal result stored in D3
000017A8  0603 0030                732              ADDI.B      #$30,D3                 * determine data register value in ASCII
000017AC  14C3                     733              MOVE.B      D3,(A2)+                * push data register number into buffer
000017AE  4EF8 1200                734              JMP         prnttoscrn              * Print out the good buffer
000017B2                           735  ********************************************************************************
000017B2                           736  * Description: AND and EXG (nibble C) - Aaron
000017B2                           737  ********************************************************************************
000017B2                           738  
000017B2  43F9 000026A0            739  ane_        LEA         bin_storage,A1          * reinitalize A0 to point to begining of bin_storage        
000017B8  2419                     740              MOVE.L      (A1)+,D2                * move bits from storage to D2
000017BA  C4BC 0000000F            741              AND.L       #and_mask1,D2           * isolate bit #8
000017C0  B43C 0000                742              CMP.B       #$00,D2                 * see if it's 0
000017C4  6700 01B2                743              BEQ         ane_ea_dn               * it is, so it is and <ea>,Dn
000017C8  2419                     744              MOVE.L      (A1)+,D2                * move last 8 from storage to D2
000017CA  C4BC FFFFF000            745              AND.L       #and_mask2,D2           * isolate opmode to see if exg      
000017D0  B4BC 01000000            746              CMP.L       #$01000000,D2           * see if it is exg_dn
000017D6  6700 001A                747              BEQ         exg_dn                  * yes it is, branch
000017DA  B4BC 01001000            748              CMP.L       #$01001000,D2           * see if it is exg_ad
000017E0  6700 006A                749              BEQ         exg_add                 * yes it is, branch
000017E4  B4BC 10001000            750              CMP.L       #$10001000,D2           * see if it is exg_d_a
000017EA  6700 00BA                751              BEQ         exg_d_a                 * yes it is, branch
000017EE  6000 0110                752              BRA         ann_dn_ea               * otherwise is and Dn,<ea>
000017F2                           753              
000017F2  41F9 000026E8            754  exg_dn      LEA         lgic_stor,A0            * load address of 'lgic' container
000017F8  5088                     755              ADDA.L      #8,A0                   * add displacement to fetch 'EXG'
000017FA  24D0                     756              MOVE.L      (A0),(A2)+              * copy word to buffer
000017FC  43F9 000026A0            757              LEA         bin_storage,A1          * reinitalize A0 to point to begining of bin_storage
00001802  14FC 0044                758              MOVE.B      #$44,(A2)+              * add a 'D' to buffer
00001806  2419                     759              MOVE.L      (A1)+,D2                * move first 8 bits into D2
00001808  C4BC 0000FFF0            760              AND.L       #and_mask4,D2           * isolate left register
0000180E  E88A                     761              LSR.L       #4,D2                   * shift to the right
00001810  7600                     762              MOVE.L      #empty,D3               * clear D3
00001812  41F9 00002680            763              LEA         bin_pattern,A0          * re-initialize A0 to point to begining of patterns
00001818  4EB9 000023A6            764              JSR         bin_to_dec              * subroutine to convert value in D2 to decimal
0000181E  0603 0030                765              ADDI.B      #$30,D3                 * determine data register value in ASCII
00001822  14C3                     766              MOVE.B      D3,(A2)+                * push data register number into buffer
00001824  14FC 002C                767              MOVE.B      #comma,(A2)+            * add a ',' to buffer
00001828  14FC 0044                768              MOVE.B      #$44,(A2)+              * add a 'D' to buffer
0000182C  2419                     769              MOVE.L      (A1)+,D2                * move last 8 bits into D2
0000182E  C4BC 00000FFF            770              AND.L       #and_mask5,D2           * isolate left register
00001834  7600                     771              MOVE.L      #empty,D3               * clear D3
00001836  41F9 00002680            772              LEA         bin_pattern,A0          * re-initialize A0 to point to begining of patterns
0000183C  4EB9 000023A6            773              JSR         bin_to_dec              * subroutine to convert value in D2 to decimal
00001842  0603 0030                774              ADDI.B      #$30,D3                 * determine data register value in ASCII
00001846  14C3                     775              MOVE.B      D3,(A2)+                * push data register number into buffer
00001848  4EF8 1200                776              JMP         prnttoscrn              * print to buffer
0000184C                           777  
0000184C  41F9 000026E8            778  exg_add     LEA         lgic_stor,A0            * load address of 'lgic' container
00001852  5088                     779              ADDA.L      #8,A0                   * add displacement to fetch 'EXG'
00001854  24D0                     780              MOVE.L      (A0),(A2)+              * copy word to buffer
00001856  43F9 000026A0            781              LEA         bin_storage,A1          * reinitalize A0 to point to begining of bin_storage
0000185C  14FC 0041                782              MOVE.B      #$41,(A2)+              * add a 'D' to buffer
00001860  2419                     783              MOVE.L      (A1)+,D2                * move first 8 bits into D2
00001862  C4BC 0000FFF0            784              AND.L       #and_mask4,D2           * isolate left register
00001868  E88A                     785              LSR.L       #4,D2                   * shift to the right
0000186A  7600                     786              MOVE.L      #empty,D3               * clear D3
0000186C  41F9 00002680            787              LEA         bin_pattern,A0          * re-initialize A0 to point to begining of patterns
00001872  4EB9 000023A6            788              JSR         bin_to_dec              * subroutine to convert value in D2 to decimal
00001878  0603 0030                789              ADDI.B      #$30,D3                 * determine data register value in ASCII
0000187C  14C3                     790              MOVE.B      D3,(A2)+                * push data register number into buffer
0000187E  14FC 002C                791              MOVE.B      #comma,(A2)+            * add a ',' to buffer
00001882  14FC 0041                792              MOVE.B      #$41,(A2)+              * add a 'D' to buffer
00001886  2419                     793              MOVE.L      (A1)+,D2                * move last 8 bits into D2
00001888  C4BC 00000FFF            794              AND.L       #and_mask5,D2           * isolate left register
0000188E  7600                     795              MOVE.L      #empty,D3               * clear D3
00001890  41F9 00002680            796              LEA         bin_pattern,A0          * re-initialize A0 to point to begining of patterns
00001896  4EB9 000023A6            797              JSR         bin_to_dec              * subroutine to convert value in D2 to decimal
0000189C  0603 0030                798              ADDI.B      #$30,D3                 * determine data register value in ASCII
000018A0  14C3                     799              MOVE.B      D3,(A2)+                * push data register number into buffer
000018A2  4EF8 1200                800              JMP         prnttoscrn              * print to buffer       
000018A6                           801              
000018A6  41F9 000026E8            802  exg_d_a     LEA         lgic_stor,A0            * load address of 'lgic' container
000018AC  5088                     803              ADDA.L      #8,A0                   * add displacement to fetch 'EXG'
000018AE  24D0                     804              MOVE.L      (A0),(A2)+              * copy word to buffer
000018B0  43F9 000026A0            805              LEA         bin_storage,A1          * reinitalize A0 to point to begining of bin_storage
000018B6  14FC 0044                806              MOVE.B      #$44,(A2)+              * add a 'D' to buffer
000018BA  2419                     807              MOVE.L      (A1)+,D2                * move first 8 bits into D2
000018BC  C4BC 0000FFF0            808              AND.L       #and_mask4,D2           * isolate left register
000018C2  E88A                     809              LSR.L       #4,D2                   * shift to the right
000018C4  7600                     810              MOVE.L      #empty,D3               * clear D3
000018C6  41F9 00002680            811              LEA         bin_pattern,A0          * re-initialize A0 to point to begining of patterns
000018CC  4EB9 000023A6            812              JSR         bin_to_dec              * subroutine to convert value in D2 to decimal
000018D2  0603 0030                813              ADDI.B      #$30,D3                 * determine data register value in ASCII
000018D6  14C3                     814              MOVE.B      D3,(A2)+                * push data register number into buffer
000018D8  14FC 002C                815              MOVE.B      #comma,(A2)+            * add a ',' to buffer
000018DC  14FC 0041                816              MOVE.B      #$41,(A2)+              * add a 'D' to buffer
000018E0  2419                     817              MOVE.L      (A1)+,D2                * move last 8 bits into D2
000018E2  C4BC 00000FFF            818              AND.L       #and_mask5,D2           * isolate left register
000018E8  7600                     819              MOVE.L      #empty,D3               * clear D3
000018EA  41F9 00002680            820              LEA         bin_pattern,A0          * re-initialize A0 to point to begining of patterns
000018F0  4EB9 000023A6            821              JSR         bin_to_dec              * subroutine to convert value in D2 to decimal
000018F6  0603 0030                822              ADDI.B      #$30,D3                 * determine data register value in ASCII
000018FA  14C3                     823              MOVE.B      D3,(A2)+                * push data register number into buffer
000018FC  4EF8 1200                824              JMP         prnttoscrn              * print to buffer                               
00001900                           825  
00001900  41F9 000026E8            826  ann_dn_ea   LEA         lgic_stor,A0            * load address of 'AND.' container
00001906  24D0                     827              MOVE.L      (A0),(A2)+              * copy word to buffer
00001908  43F9 000026A0            828              LEA         bin_storage,A1          * reinitalize A0 to point to begining of bin_storage
0000190E  3419                     829              MOVE.W      (A1)+,D2                * move first 4 bits into D2
00001910  2419                     830              MOVE.L      (A1)+,D2                * move next 8 bits into D2
00001912  C4BC 0000FF00            831              AND.L       #and_mask3,D2           * mask to isolate last two bits of opmode
00001918  E08A                     832              LSR.L       #8,D2                   * shift to align with LSB
0000191A  7600                     833              MOVE.L      #empty,D3               * clear D3 register     
0000191C  41F9 00002680            834              LEA         bin_pattern,A0          * re-initialize A0 to point to begining of patterns
00001922  4EB9 000023A6            835              JSR         bin_to_dec              * subroutine to convert value in D2 to decimal
00001928  4EB9 00002276            836              JSR         appends                 * append 'L', 'W', or 'B' to buffer
0000192E  43F9 000026A0            837              LEA         bin_storage,A1          * reinitalize A0 to point to begining of bin_storage
00001934  2419                     838              MOVE.L      (A1)+,D2                * move first 8 bits into D2
00001936  C4BC 0000FFF0            839              AND.L       #and_mask4,D2           * mask to isolate register
0000193C  E88A                     840              LSR.L       #4,D2
0000193E  7600                     841              MOVE.L      #empty,D3               * clear D3
00001940  41F9 00002680            842              LEA         bin_pattern,A0          * re-initalize A0 to point to begining of patterns
00001946  4EB9 000023A6            843              JSR         bin_to_dec              * convert value in D2 to decimal
0000194C  14FC 0020                844              MOVE.B      #space,(A2)+            * add a space to buffer
00001950  14FC 0044                845              MOVE.B      #$44,(A2)+              * add a 'D' to buffer
00001954  0603 0030                846              ADDI.B      #$30,D3                 * determine data register value in ASCII
00001958  14C3                     847              MOVE.B      D3,(A2)+                * push data register number into buffer
0000195A  14FC 002C                848              MOVE.B      #comma,(A2)+            * add a ',' to buffer
0000195E  43F9 000026A0            849              LEA         bin_storage,A1          * re-initalize A1 to point to begining of storage
00001964  2419                     850              MOVE.L      (A1)+,D2                * store left 8 bits into D2
00001966  2419                     851              MOVE.L      (A1)+,D2                * store right most 8 bits into D2
00001968  C4BC 00FFFFFF            852              AND.L       #arith_mask4,D2         * mask to isolate last 6 bits
0000196E  4EB9 000020BA            853              JSR         genEA                   * goto subroutine 'genEA'
00001974  4EF8 1200                854              JMP         prnttoscrn              * JUST TO TEST IF IT WILL PRINT OUT THE BUFFER
00001978                           855  
00001978  41F9 000026E8            856  ane_ea_dn   LEA         lgic_stor,A0            * load address of 'AND.' container
0000197E  24D0                     857              MOVE.L      (A0),(A2)+              * copy word to buffer
00001980  C4BC 000000FF            858              AND.L       #arith_mask3,D2         * isolate the right 2 bits of opmode to determine if it's a L,W,or B
00001986  7600                     859              MOVE.L      #empty,D3               * clear D3 register     
00001988  41F9 00002680            860              LEA         bin_pattern,A0          * re-initialize A0 to point to begining of patterns
0000198E  4EB9 000023A6            861              JSR         bin_to_dec              * subroutine to convert value in D2 to decimal
00001994  4EB9 00002276            862              JSR         appends                 * append 'L', 'W', or 'B' to buffer 
0000199A  14FC 0020                863              MOVE.B      #space,(A2)+            * add a space to buffer
0000199E  43F9 000026A0            864              LEA         bin_storage,A1          * re-initalize A1 to point to begining of storage
000019A4  2419                     865              MOVE.L      (A1)+,D2                * store left 8 bits into D2
000019A6  2419                     866              MOVE.L      (A1)+,D2                * store right most 8 bits into D2
000019A8  C4BC 00FFFFFF            867              AND.L       #arith_mask4,D2         * mask to isolate last 6 bits
000019AE  4EB9 000020BA            868              JSR         genEA                   * pass control to effective address
000019B4  14FC 002C                869              MOVE.B      #comma,(A2)+            * add a ',' to buffer
000019B8  14FC 0044                870              MOVE.B      #$44,(A2)+              * add a 'D' to buffer
000019BC  43F9 000026A0            871              LEA         bin_storage,A1          * re-initalize A1 to point to begining of binary opcode
000019C2  2411                     872              MOVE.L      (A1),D2                 * move first 8 bits into D2
000019C4  C4BC 0000FFF0            873              AND.L       #arith_mask5,D2         * mask to isolate the register value bits
000019CA  E88A                     874              LSR.L       #4,D2                   * shift bits in D2 to the right
000019CC  7600                     875              MOVE.L      #empty,D3               * clear D3
000019CE  41F9 00002680            876              LEA         bin_pattern,A0          * re-initalize A0 to point to begining of patterns
000019D4  4EB9 000023A6            877              JSR         bin_to_dec              * convert value in D2 to decimal, decimal result stored in D3
000019DA  0603 0030                878              ADDI.B      #$30,D3                 * determine data register value in ASCII
000019DE  14C3                     879              MOVE.B      D3,(A2)+                * push data register number into buffer
000019E0  4EF8 1200                880              JMP         prnttoscrn
000019E4                           881  
000019E4                           882  ********************************************************************************
000019E4                           883  * Description: SUB and SUBA (nibble 9) - Neal
000019E4                           884  ********************************************************************************
000019E4                           885  
000019E4  41F9 000026C0            886  sub_        LEA         math_stor,A0            * load address of 'add' container
000019EA  D1FC 0000000C            887              ADDA.L      #12,A0                  * add displacement to fetch 'ADDA'
000019F0  24D0                     888              MOVE.L      (A0),(A2)+              * copy word to buffer
000019F2  2411                     889              MOVE.L      (A1),D2                 * move bits from storage to D2
000019F4  C4BC 000FFF00            890              AND.L       #arith_mask1,D2         * isolate opmode
000019FA  E08A                     891              LSR.L       #8,D2                   * shift opcode bits to right
000019FC  7600                     892              MOVE.L      #empty,D3               * clear D3 register     
000019FE  41F9 00002680            893              LEA         bin_pattern,A0          * re-initialize A0 to point to begining of patterns
00001A04  4EB9 000023A6            894              JSR         bin_to_dec              * convert opcode to decimal
00001A0A  B63C 0003                895              CMP.B       #$3,D3                  * if decimal is == to 3, then instruction is ADDA
00001A0E  6700 00DE                896              BEQ         suba_ea_dn              * GOING TO ADDA (used done just to temporarily fill)
00001A12  B63C 0007                897              CMP.B       #$7,D3                  * if decimal is == to 7, then instruction is also ADDA
00001A16  6700 00D6                898              BEQ         suba_ea_dn              * GOING TO ADDA (used done just to temporarily fill)
00001A1A  B63C 0004                899              CMP.B       #$4,D3                  * if decimal is < 4, then instruction is ADD Dn+<ea>
00001A1E  6C00 000A                900              BGE         sub_dn_ea               * branch to label                   
00001A22  B63C 0004                901              CMP.B       #$4,D3                  * if decimal is > 4, then instruction is ADD <ea>+Dn
00001A26  6D00 0062                902              BLT         sub_ea_dn               * branch to label
00001A2A                           903  
00001A2A  C4BC 000000FF            904  sub_dn_ea   AND.L       #arith_mask3,D2         * isolate the right 2 bits of opmode to determine if it's a L,W,or B
00001A30  7600                     905              MOVE.L      #empty,D3               * clear D3 register     
00001A32  41F9 00002680            906              LEA         bin_pattern,A0          * re-initialize A0 to point to begining of patterns
00001A38  4EB9 000023A6            907              JSR         bin_to_dec              * subroutine to convert value in D2 to decimal
00001A3E  4EB9 00002276            908              JSR         appends                 * append 'L', 'W', or 'B' to buffer
00001A44  2411                     909              MOVE.L      (A1),D2                 * move bits from storage to D2
00001A46  C4BC FFF00000            910              AND.L       #arith_mask2,D2         * mask to isolate register
00001A4C  E19A                     911              ROL.L       #8,D2                   * push bits to correct position
00001A4E  E99A                     912              ROL.L       #4,D2                   * push it a little more
00001A50  7600                     913              MOVE.L      #empty,D3               * clear D3
00001A52  41F9 00002680            914              LEA         bin_pattern,A0          * re-initalize A0 to point to begining of patterns
00001A58  4EB9 000023A6            915              JSR         bin_to_dec              * convert value in D2 to decimal
00001A5E  14FC 0020                916              MOVE.B      #space,(A2)+            * add a space to buffer
00001A62  14FC 0044                917              MOVE.B      #$44,(A2)+              * add a 'D' to buffer
00001A66  0603 0030                918              ADDI.B      #$30,D3                 * determine data register value in ASCII
00001A6A  14C3                     919              MOVE.B      D3,(A2)+                * push data register number into buffer
00001A6C  14FC 002C                920              MOVE.B      #comma,(A2)+            * add a ',' to buffer
00001A70  43F9 000026A0            921              LEA         bin_storage,A1          * re-initalize A1 to point to begining of storage
00001A76  2419                     922              MOVE.L      (A1)+,D2                * store left 8 bits into D2
00001A78  2419                     923              MOVE.L      (A1)+,D2                * store right most 8 bits into D2
00001A7A  C4BC 00FFFFFF            924              AND.L       #arith_mask4,D2         * mask to isolate last 6 bits
00001A80  4EB9 000020BA            925              JSR         genEA                   * goto subroutine 'genEA'
00001A86  4EF8 1200                926              JMP         prnttoscrn              * JUST TO TEST IF IT WILL PRINT OUT THE BUFFER
00001A8A                           927  
00001A8A  C4BC 000000FF            928  sub_ea_dn   AND.L       #arith_mask3,D2         * isolate the right 2 bits of opmode to determine if it's a L,W,or B
00001A90  7600                     929              MOVE.L      #empty,D3               * clear D3 register     
00001A92  41F9 00002680            930              LEA         bin_pattern,A0          * re-initialize A0 to point to begining of patterns
00001A98  4EB9 000023A6            931              JSR         bin_to_dec              * subroutine to convert value in D2 to decimal
00001A9E  4EB9 00002276            932              JSR         appends                 * append 'L', 'W', or 'B' to buffer 
00001AA4  14FC 0020                933              MOVE.B      #space,(A2)+            * add a space to buffer
00001AA8  43F9 000026A0            934              LEA         bin_storage,A1          * re-initalize A1 to point to begining of storage
00001AAE  2419                     935              MOVE.L      (A1)+,D2                * store left 8 bits into D2
00001AB0  2419                     936              MOVE.L      (A1)+,D2                * store right most 8 bits into D2
00001AB2  C4BC 00FFFFFF            937              AND.L       #arith_mask4,D2         * mask to isolate last 6 bits
00001AB8  4EB9 000020BA            938              JSR         genEA                   * pass control to effective address
00001ABE  14FC 002C                939              MOVE.B      #comma,(A2)+            * add a ',' to buffer
00001AC2  14FC 0044                940              MOVE.B      #$44,(A2)+              * add a 'D' to buffer
00001AC6  43F9 000026A0            941              LEA         bin_storage,A1          * re-initalize A1 to point to begining of binary opcode
00001ACC  2411                     942              MOVE.L      (A1),D2                 * move first 8 bits into D2
00001ACE  C4BC 0000FFF0            943              AND.L       #arith_mask5,D2         * mask to isolate the register value bits
00001AD4  E88A                     944              LSR.L       #4,D2                   * shift bits in D2 to the right
00001AD6  7600                     945              MOVE.L      #empty,D3               * clear D3
00001AD8  41F9 00002680            946              LEA         bin_pattern,A0          * re-initalize A0 to point to begining of patterns
00001ADE  4EB9 000023A6            947              JSR         bin_to_dec              * convert value in D2 to decimal, decimal result stored in D3
00001AE4  0603 0030                948              ADDI.B      #$30,D3                 * determine data register value in ASCII
00001AE8  14C3                     949              MOVE.B      D3,(A2)+                * push data register number into buffer
00001AEA  4EF8 1200                950              JMP         prnttoscrn
00001AEE                           951  
00001AEE  41F9 000026C0            952  suba_ea_dn  LEA         math_stor,A0            * load address of 'add' container
00001AF4  D1FC 00000010            953              ADDA.L      #16,A0                  * add displacement to fetch 'ADDA'
00001AFA  24D0                     954              MOVE.L      (A0),(A2)+              * copy word to buffer
00001AFC  B47C 0011                955              CMP.W       #$0011,D2
00001B00  6700 0052                956              BEQ         suba_s_w
00001B04  B47C 0111                957              CMP.W       #$0111,D2
00001B08  6700 0050                958              BEQ         suba_s_l
00001B0C  14FC 0020                959  cont_suba   MOVE.B      #space,(A2)+            * add a space to buffer
00001B10  43F9 000026A0            960              LEA         bin_storage,A1          * re-initalize A1 to point to begining of storage
00001B16  2419                     961              MOVE.L      (A1)+,D2                * store left 8 bits into D2
00001B18  2419                     962              MOVE.L      (A1)+,D2                * store right most 8 bits into D2
00001B1A  C4BC 00FFFFFF            963              AND.L       #arith_mask4,D2         * mask to isolate last 6 bits
00001B20  4EB9 000020BA            964              JSR         genEA                   * pass control to effective address
00001B26  14FC 002C                965              MOVE.B      #comma,(A2)+            * add a ',' to buffer
00001B2A  14FC 0041                966              MOVE.B      #$41,(A2)+              * add a 'A' to buffer
00001B2E  43F9 000026A0            967              LEA         bin_storage,A1          * re-initalize A1 to point to begining of binary opcode
00001B34  2411                     968              MOVE.L      (A1),D2                 * move first 8 bits into D2
00001B36  C4BC 0000FFF0            969              AND.L       #arith_mask5,D2         * mask to isolate the register value bits
00001B3C  E88A                     970              LSR.L       #4,D2                   * shift bits in D2 to the right
00001B3E  7600                     971              MOVE.L      #empty,D3               * clear D3
00001B40  41F9 00002680            972              LEA         bin_pattern,A0          * re-initalize A0 to point to begining of patterns
00001B46  4EB9 000023A6            973              JSR         bin_to_dec              * convert value in D2 to decimal, decimal result stored in D3
00001B4C  0603 0030                974              ADDI.B      #$30,D3                 * determine data register value in ASCII
00001B50  14C3                     975              MOVE.B      D3,(A2)+                * push data register number into buffer
00001B52  4E75                     976              RTS                                 * JUST TO TEST IF IT WILL PRINT OUT THE BUFFER
00001B54                           977  
00001B54  34FC 2E57                978  suba_s_w    MOVE.W      #$2E57,(A2)+
00001B58  60B2                     979              BRA         cont_suba
00001B5A                           980  
00001B5A  34FC 2E4C                981  suba_s_l    MOVE.W      #$2E4C,(A2)+
00001B5E  60AC                     982              BRA         cont_suba
00001B60                           983  ********************************************************************************
00001B60                           984  * Description: CMP, CMPA, EOR (nibble B) - Neal
00001B60                           985  ********************************************************************************
00001B60  2411                     986  cmpsr       MOVE.L      (A1),D2                 * move bits from storage to D2
00001B62  C4BC 000FFF00            987              AND.L       #arith_mask1,D2         * isolate opmode
00001B68  E08A                     988              LSR.L       #8,D2                   * shift opcode bits to right
00001B6A  7600                     989              MOVE.L      #empty,D3               * clear D3 register     
00001B6C  B47C 0000                990              CMP.W       #$0000,D2               * if D2 == 0000, opcode is cmp
00001B70  6700 0026                991              BEQ         cmp_                    * yes, it is cmp
00001B74  B47C 0001                992              CMP.W       #$0001,D2               * if D2 == 0000, opcode is cmp
00001B78  6700 001E                993              BEQ         cmp_                    * yes, it is cmp
00001B7C  B47C 0010                994              CMP.W       #$0010,D2               * if D2 == 0000, opcode is cmp
00001B80  6700 0016                995              BEQ         cmp_                    * yes, it is cmp
00001B84  B47C 0011                996              CMP.W       #$0011,D2               * if D2 == 0000, opcode is cmpa
00001B88  6700 007A                997              BEQ         cmpa_                   * yes, it is cmpa
00001B8C  B47C 0111                998              CMP.W       #$0111,D2               * if D2 == 0000, opcode is cmpa
00001B90  6700 0072                999              BEQ         cmpa_                   * yes, it is cmpa
00001B94  6000 00D2               1000              BRA         eor_                    * otherwise opcode is eor
00001B98                          1001  
00001B98  41F9 0000270C           1002  cmp_        LEA         comp_stor,A0            * load address of 'add' container
00001B9E  24D0                    1003              MOVE.L      (A0),(A2)+              * copy word to buffer
00001BA0  C4BC 000000FF           1004              AND.L       #arith_mask3,D2         * isolate the right 2 bits of opmode to determine if it's a L,W,or B
00001BA6  7600                    1005              MOVE.L      #empty,D3               * clear D3 register     
00001BA8  41F9 00002680           1006              LEA         bin_pattern,A0          * re-initialize A0 to point to begining of patterns
00001BAE  4EB9 000023A6           1007              JSR         bin_to_dec              * subroutine to convert value in D2 to decimal
00001BB4  4EB9 00002276           1008              JSR         appends                 * append 'L', 'W', or 'B' to buffer 
00001BBA  14FC 0020               1009              MOVE.B      #space,(A2)+            * add a space to buffer
00001BBE  43F9 000026A0           1010              LEA         bin_storage,A1          * re-initalize A1 to point to begining of storage
00001BC4  2419                    1011              MOVE.L      (A1)+,D2                * store left 8 bits into D2
00001BC6  2419                    1012              MOVE.L      (A1)+,D2                * store right most 8 bits into D2
00001BC8  C4BC 00FFFFFF           1013              AND.L       #arith_mask4,D2         * mask to isolate last 6 bits
00001BCE  4EB9 000020BA           1014              JSR         genEA                   * pass control to effective address
00001BD4  14FC 002C               1015              MOVE.B      #comma,(A2)+            * add a ',' to buffer
00001BD8  14FC 0044               1016              MOVE.B      #$44,(A2)+              * add a 'D' to buffer
00001BDC  43F9 000026A0           1017              LEA         bin_storage,A1          * re-initalize A1 to point to begining of binary opcode
00001BE2  2411                    1018              MOVE.L      (A1),D2                 * move first 8 bits into D2
00001BE4  C4BC 0000FFF0           1019              AND.L       #arith_mask5,D2         * mask to isolate the register value bits
00001BEA  E88A                    1020              LSR.L       #4,D2                   * shift bits in D2 to the right
00001BEC  7600                    1021              MOVE.L      #empty,D3               * clear D3
00001BEE  41F9 00002680           1022              LEA         bin_pattern,A0          * re-initalize A0 to point to begining of patterns
00001BF4  4EB9 000023A6           1023              JSR         bin_to_dec              * convert value in D2 to decimal, decimal result stored in D3
00001BFA  0603 0030               1024              ADDI.B      #$30,D3                 * determine data register value in ASCII
00001BFE  14C3                    1025              MOVE.B      D3,(A2)+                * push data register number into buffer
00001C00  4EF8 1200               1026              JMP         prnttoscrn              * print buffer
00001C04                          1027  
00001C04  41F9 0000270C           1028  cmpa_       LEA         comp_stor,A0            * load address of 'add' container
00001C0A  5888                    1029              ADDA.L      #4,A0                   * add displacement to fetch 'ADDA'
00001C0C  24D0                    1030              MOVE.L      (A0),(A2)+              * copy word to buffer
00001C0E  B47C 0011               1031              CMP.W       #$0011,D2               * check if last two bits are 11
00001C12  6700 00BE               1032              BEQ         cmpa_w                  * yes they are, this means its of length w
00001C16  B47C 0111               1033              CMP.W       #$0111,D2               * check if last bits are 111
00001C1A  6700 00BE               1034              BEQ         cmpa_l                  * yes they are, this means its of length l
00001C1E  14FC 0020               1035  cont_cmpa   MOVE.B      #space,(A2)+            * add a space to buffer
00001C22  43F9 000026A0           1036              LEA         bin_storage,A1          * re-initalize A1 to point to begining of storage
00001C28  2419                    1037              MOVE.L      (A1)+,D2                * store left 8 bits into D2
00001C2A  2419                    1038              MOVE.L      (A1)+,D2                * store right most 8 bits into D2
00001C2C  C4BC 00FFFFFF           1039              AND.L       #arith_mask4,D2         * mask to isolate last 6 bits
00001C32  4EB9 000020BA           1040              JSR         genEA                   * pass control to effective address
00001C38  14FC 002C               1041              MOVE.B      #comma,(A2)+            * add a ',' to buffer
00001C3C  14FC 0041               1042              MOVE.B      #$41,(A2)+              * add a 'D' to buffer
00001C40  43F9 000026A0           1043              LEA         bin_storage,A1          * re-initalize A1 to point to begining of binary opcode
00001C46  2411                    1044              MOVE.L      (A1),D2                 * move first 8 bits into D2
00001C48  C4BC 0000FFF0           1045              AND.L       #arith_mask5,D2         * mask to isolate the register value bits
00001C4E  E88A                    1046              LSR.L       #4,D2                   * shift bits in D2 to the right
00001C50  7600                    1047              MOVE.L      #empty,D3               * clear D3
00001C52  41F9 00002680           1048              LEA         bin_pattern,A0          * re-initalize A0 to point to begining of patterns
00001C58  4EB9 000023A6           1049              JSR         bin_to_dec              * convert value in D2 to decimal, decimal result stored in D3
00001C5E  0603 0030               1050              ADDI.B      #$30,D3                 * determine data register value in ASCII
00001C62  14C3                    1051              MOVE.B      D3,(A2)+                * push data register number into buffer
00001C64  4EF8 1200               1052              JMP         prnttoscrn              * print buffer
00001C68                          1053              
00001C68  41F9 0000270C           1054  eor_        LEA         comp_stor,A0            * load address of 'add' container
00001C6E  5088                    1055              ADDA.L      #8,A0                   * add displacement to fetch 'EOR.'
00001C70  24D0                    1056              MOVE.L      (A0),(A2)+              * copy word to buffer
00001C72  C4BC 000000FF           1057              AND.L       #arith_mask3,D2         * isolate the right 2 bits of opmode to determine if it's a L,W,or B
00001C78  7600                    1058              MOVE.L      #empty,D3               * clear D3 register     
00001C7A  41F9 00002680           1059              LEA         bin_pattern,A0          * re-initialize A0 to point to begining of patterns
00001C80  4EB9 000023A6           1060              JSR         bin_to_dec              * subroutine to convert value in D2 to decimal
00001C86  4EB9 00002276           1061              JSR         appends                 * append 'L', 'W', or 'B' to buffer
00001C8C  2411                    1062              MOVE.L      (A1),D2                 * move bits from storage to D2
00001C8E  C4BC FFF00000           1063              AND.L       #arith_mask2,D2         * mask to isolate register
00001C94  E19A                    1064              ROL.L       #8,D2                   * push bits to correct position
00001C96  E99A                    1065              ROL.L       #4,D2                   * push it a little more
00001C98  7600                    1066              MOVE.L      #empty,D3               * clear D3
00001C9A  41F9 00002680           1067              LEA         bin_pattern,A0          * re-initalize A0 to point to begining of patterns
00001CA0  4EB9 000023A6           1068              JSR         bin_to_dec              * convert value in D2 to decimal
00001CA6  14FC 0020               1069              MOVE.B      #space,(A2)+            * add a space to buffer
00001CAA  14FC 0044               1070              MOVE.B      #$44,(A2)+              * add a 'D' to buffer
00001CAE  0603 0030               1071              ADDI.B      #$30,D3                 * determine data register value in ASCII
00001CB2  14C3                    1072              MOVE.B      D3,(A2)+                * push data register number into buffer
00001CB4  14FC 002C               1073              MOVE.B      #comma,(A2)+            * add a ',' to buffer
00001CB8  43F9 000026A0           1074              LEA         bin_storage,A1          * re-initalize A1 to point to begining of storage
00001CBE  2419                    1075              MOVE.L      (A1)+,D2                * store left 8 bits into D2
00001CC0  2419                    1076              MOVE.L      (A1)+,D2                * store right most 8 bits into D2
00001CC2  C4BC 00FFFFFF           1077              AND.L       #arith_mask4,D2         * mask to isolate last 6 bits
00001CC8  4EB9 000020BA           1078              JSR         genEA                   * goto subroutine 'genEA'
00001CCE  4EF8 1200               1079              JMP         prnttoscrn              * print buffer
00001CD2                          1080  
00001CD2  34FC 2E57               1081  cmpa_w      MOVE.W      #$2E57,(A2)+            * append '.W'
00001CD6  4EF8 1C1E               1082              JMP         cont_cmpa               * jumpt to continue finishing
00001CDA                          1083  
00001CDA  34FC 2E4C               1084  cmpa_l      MOVE.W      #$2E4C,(A2)+            * append '.L'
00001CDE  4EF8 1C1E               1085              JMP         cont_cmpa               * jump to continue finishing
00001CE2                          1086  ********************************************************************************
00001CE2                          1087  * Description: MOVE (nibble 1) - Aaron
00001CE2                          1088  ********************************************************************************
00001CE2  41F9 0000271C           1089  moveb_      LEA         move_stor,A0            * load address of storage
00001CE8  24D0                    1090              MOVE.L      (A0),(A2)+              * copy word from storage to buffer
00001CEA  14FC 002E               1091              MOVE.B      #dot,(A2)+              * add . to buffer
00001CEE  14FC 0042               1092              MOVE.B      #byte,(A2)+             * add B to buffer
00001CF2  34FC 2020               1093              MOVE.W      #dspace,(A2)+           * add space to buffer
00001CF6  4EB9 000023DE           1094              JSR         movesr                  * goto subroutine for MOVE EA
00001CFC                          1095  ********************************************************************************
00001CFC                          1096  * Description: MOVE, MOVEA type Long (nibble 2) - Aaron
00001CFC                          1097  ********************************************************************************
00001CFC  41F9 0000271C           1098  movel_      LEA         move_stor,A0            * load address of storage
00001D02  24D0                    1099              MOVE.L      (A0),(A2)+              * copy word from storage to buffer
00001D04  3200                    1100              MOVE.W      D0,D1                   * copy word to register D1
00001D06  0281 000001C0           1101              ANDI.L      #b68_mask,D1            * isolate bits 6 - 8
00001D0C  EC89                    1102              LSR.L       #6,D1                   * shift bits to LSB position
00001D0E  0C01 0001               1103              CMPI.B      #1,D1                   * check if moving address
00001D12  6700 0014               1104              BEq         moveal_                 * branch to "moveal_"
00001D16  14FC 002E               1105              MOVE.B      #dot,(A2)+              * add . to buffer
00001D1A  14FC 004C               1106              MOVE.B      #long,(A2)+             * add L to buffer
00001D1E  34FC 2020               1107              MOVE.W      #dspace,(A2)+           * add space to buffer
00001D22  4EB9 000023DE           1108              JSR         movesr                  * goto subroutine for MOVE EA
00001D28                          1109              
00001D28  14FC 0041               1110  moveal_     MOVE.B      #$41,(A2)+              * add A to buffer
00001D2C  14FC 002E               1111              MOVE.B      #dot,(A2)+              * add . to buffer
00001D30  14FC 004C               1112              MOVE.B      #long,(A2)+             * add L to buffer
00001D34  14FC 0020               1113              MOVE.B      #space,(A2)+            * add space to buffer
00001D38  4EB9 0000240E           1114              JSR         moveasr                 * goto subroutine for MOVEA EA
00001D3E                          1115  ********************************************************************************
00001D3E                          1116  * Description: MOVE, MOVEA type Word (nibble 3) - Aaron
00001D3E                          1117  ********************************************************************************
00001D3E  41F9 0000271C           1118  movew_      LEA         move_stor,A0            * load address of storage
00001D44  24D0                    1119              MOVE.L      (A0),(A2)+              * copy word from storage to buffer
00001D46  3200                    1120              MOVE.W      D0,D1                   * copy word to register D1
00001D48  0281 000001C0           1121              ANDI.L      #b68_mask,D1            * isolate bits 6 - 8
00001D4E  EC89                    1122              LSR.L       #6,D1                   * shift bits to LSB position
00001D50  0C01 0001               1123              CMPI.B      #1,D1                   * check if moving address
00001D54  6700 0014               1124              BEq         moveaw_                 * branch to "moveaw_"
00001D58  14FC 002E               1125              MOVE.B      #dot,(A2)+              * add . to buffer
00001D5C  14FC 0057               1126              MOVE.B      #word,(A2)+             * add W to buffer
00001D60  34FC 2020               1127              MOVE.W      #dspace,(A2)+           * add space to buffer
00001D64  4EB9 000023DE           1128              JSR         movesr                  * goto subroutine for MOVE EA
00001D6A                          1129  
00001D6A  14FC 0041               1130  moveaw_     MOVE.B      #$41,(A2)+              * add A to buffer
00001D6E  14FC 002E               1131              MOVE.B      #dot,(A2)+              * add . to buffer
00001D72  14FC 0057               1132              MOVE.B      #word,(A2)+             * add W to buffer
00001D76  14FC 0020               1133              MOVE.B      #space,(A2)+            * add space to buffer
00001D7A  4EB9 0000240E           1134              JSR         moveasr                 * goto subroutine for MOVEA EA
00001D80                          1135  ********************************************************************************
00001D80                          1136  * Description: ASL, ASR, LSL, LSR, ROL, ROR (nibble E) - Neal
00001D80                          1137  ********************************************************************************
00001D80  43F9 000026A0           1138  manip_      LEA         bin_storage,A1          * re-initalize A1 to point to begining of storage
00001D86  2419                    1139              MOVE.L      (A1)+,D2                * move bits from storage to D2
00001D88  2419                    1140              MOVE.L      (A1)+,D2                * move bits from storage to D2
00001D8A  C4BC 000FF000           1141              AND.L       #manip_mask2,D2         * isolate bits 4/3 to see if its AS LS RO
00001D90  B4BC 00000000           1142              CMP.L       #$00000000,D2           * next 8 bits == compare statement
00001D96  6700 001A               1143              BEQ         ashift                  * yes, so it is an AS
00001D9A  B4BC 00001000           1144              CMP.L       #$00001000,D2           * next 8 bits == compare statement
00001DA0  6700 003E               1145              BEQ         lshift                  * yes, so it is a LS
00001DA4  B4BC 00011000           1146              CMP.L       #$00011000,D2           * next 8 bits == compare statement
00001DAA  6700 0068               1147              BEQ         rotate                  * yes, so it is a RO
00001DAE  4EF8 11F2               1148              JMP         setBad                  * it is neither of these, print error
00001DB2                          1149              
00001DB2  41F9 000026F4           1150  ashift      LEA         mani_stor,A0            * load address of manip container
00001DB8  43F9 000026A0           1151              LEA         bin_storage,A1          * re-initalize A1 to point to begining of storage
00001DBE  2419                    1152              MOVE.L      (A1)+,D2                * move bits from storage to D2
00001DC0  C4BC 0000000F           1153              AND.L       #manip_mask3,D2         * isolate direction
00001DC6  B43C 0001               1154              CMP.B       #$01,D2                 * see if it's left
00001DCA  6600 000A               1155              BNE         asapright               * it's not left
00001DCE  24D0                    1156              MOVE.L      (A0),(A2)+              * copy 'ASL' to buffer
00001DD0  4EF9 00001E4C           1157              JMP         manipjmp1               * jump to finish decoding
00001DD6  5888                    1158  asapright   ADDA.L      #4,A0                   * add displacement to fetch 'ASR'
00001DD8  24D0                    1159              MOVE.L      (A0),(A2)+              * copy 'ASR' to buffer  
00001DDA  4EF9 00001E4C           1160              JMP         manipjmp1               * jump to finish decoding
00001DE0                          1161  
00001DE0  41F9 000026F4           1162  lshift      LEA         mani_stor,A0            * load address of manip container
00001DE6  43F9 000026A0           1163              LEA         bin_storage,A1          * re-initalize A1 to point to begining of storage
00001DEC  2419                    1164              MOVE.L      (A1)+,D2                * move bits from storage to D2
00001DEE  C4BC 0000000F           1165              AND.L       #manip_mask3,D2         * isolate direction
00001DF4  B43C 0001               1166              CMP.B       #$01,D2                 * see if it's left
00001DF8  6600 000C               1167              BNE         lsright                 * it's not left
00001DFC  5088                    1168              ADDA.L      #8,A0                   * add displacement to fetch 'LSL'
00001DFE  24D0                    1169              MOVE.L      (A0),(A2)+              * copy 'LSL' to buffer
00001E00  4EF9 00001E4C           1170              JMP         manipjmp1               * jump to finish decoding
00001E06  D1FC 0000000C           1171  lsright     ADDA.L      #12,A0                  * add displacement to fetch 'LSR'
00001E0C  24D0                    1172              MOVE.L      (A0),(A2)+              * copy 'LSR' to buffer  
00001E0E  4EF9 00001E4C           1173              JMP         manipjmp1               * jump to finish decoding
00001E14                          1174              
00001E14  41F9 000026F4           1175  rotate      LEA         mani_stor,A0            * load address of manip container
00001E1A  43F9 000026A0           1176              LEA         bin_storage,A1          * re-initalize A1 to point to begining of storage
00001E20  2419                    1177              MOVE.L      (A1)+,D2                * move bits from storage to D2
00001E22  C4BC 0000000F           1178              AND.L       #manip_mask3,D2         * isolate direction
00001E28  B43C 0001               1179              CMP.B       #$01,D2                 * see if it's left
00001E2C  6600 0010               1180              BNE         rotright                * it's not left
00001E30  D1FC 00000010           1181              ADDA.L      #16,A0                  * add displacement to fetch 'LSL'
00001E36  24D0                    1182              MOVE.L      (A0),(A2)+              * copy 'LSL' to buffer
00001E38  4EF9 00001E4C           1183              JMP         manipjmp1               * jump to finish decoding
00001E3E  D1FC 00000014           1184  rotright    ADDA.L      #20,A0                  * add displacement to fetch 'LSR'
00001E44  24D0                    1185              MOVE.L      (A0),(A2)+              * copy 'LSR' to buffer  
00001E46  4EF9 00001E4C           1186              JMP         manipjmp1               * jump to finish decoding
00001E4C                          1187              
00001E4C  2419                    1188  manipjmp1   MOVE.L      (A1)+,D2                * move last 8 bits from storage to D2
00001E4E  C4BC FF000000           1189              AND.L       #manip_mask7,D2         * isolate the size
00001E54  B4BC 11000000           1190              CMP.L       #$11000000,D2           * see if it has to do with EA
00001E5A  6700 0098               1191              BEQ         mani_ea                 * yes, branch
00001E5E  14FC 002E               1192              MOVE.B      #dot,(A2)+              * add a '.' to buffer
00001E62  E08A                    1193              LSR.L       #8,D2                   * shift
00001E64  E08A                    1194              LSR.L       #8,D2                   * continue to shift
00001E66  E08A                    1195              LSR.L       #8,D2                   * last shift to LSD
00001E68  7600                    1196              MOVE.L      #empty,D3               * clear D3 register     
00001E6A  41F9 00002680           1197              LEA         bin_pattern,A0          * re-initialize A0 to point to begining of patterns
00001E70  4EB9 000023A6           1198              JSR         bin_to_dec              * subroutine to convert value in D2 to decimal
00001E76  4EB9 00002276           1199              JSR         appends                 * append 'L', 'W', or 'B' to buffer             
00001E7C  14FC 0020               1200              MOVE.B      #space,(A2)+            * add a space to buffer
00001E80  43F9 000026A0           1201              LEA         bin_storage,A1          * re-initalize A1 to point to begining of storage
00001E86  2419                    1202              MOVE.L      (A1)+,D2                * move bits from storage to D2
00001E88  2419                    1203              MOVE.L      (A1)+,D2                * move last 8 bits from storage to D2
00001E8A  C4BC 00F00000           1204              AND.L       #manip_mask4,D2         * isolate i/r bit
00001E90  B4BC 00100000           1205              CMP.L       #$00100000,D2           * see if it's going to be a data reg
00001E96  6600 000C               1206              BNE         mani_apd                * jump to append a pound
00001E9A  14FC 0044               1207              MOVE.B      #$44,(A2)+              * append a 'D' for data register
00001E9E  4EF9 00001EA8           1208              JMP         manijmp2                * jump to continue doing work
00001EA4  14FC 0023               1209  mani_apd    MOVE.B      #$23,(A2)+              * append a pound
00001EA8  43F9 000026A0           1210  manijmp2    LEA         bin_storage,A1          * re-initalize A1 to point to begining of storage
00001EAE  2419                    1211              MOVE.L      (A1)+,D2                * move bits from storage to D2
00001EB0  C4BC 0000FFF0           1212              AND.L       #manip_mask5,D2         * isolate the count
00001EB6  E88A                    1213              LSR.L       #4,D2                   * shift to the right
00001EB8  7600                    1214              MOVE.L      #empty,D3               * clear D3
00001EBA  41F9 00002680           1215              LEA         bin_pattern,A0          * re-initalize A0 to point to begining of patterns
00001EC0  4EB9 000023A6           1216              JSR         bin_to_dec              * convert value in D2 to decimal
00001EC6  0603 0030               1217              ADDI.B      #$30,D3                 * determine data register value in ASCII
00001ECA  14C3                    1218              MOVE.B      D3,(A2)+                * push data register number into buffer
00001ECC  14FC 002C               1219              MOVE.B      #comma,(A2)+            * add a ',' to buffer
00001ED0  14FC 0044               1220              MOVE.B      #$44,(A2)+              * add a 'D' to buffer
00001ED4  2419                    1221              MOVE.L      (A1)+,D2                * move last 8 bits from storage to D2
00001ED6  C4BC 00000FFF           1222              AND.L       #manip_mask6,D2         * isolate the register
00001EDC  7600                    1223              MOVE.L      #empty,D3               * clear D3
00001EDE  41F9 00002680           1224              LEA         bin_pattern,A0          * re-initalize A0 to point to begining of patterns
00001EE4  4EB9 000023A6           1225              JSR         bin_to_dec              * convert value in D2 to decimal
00001EEA  0603 0030               1226              ADDI.B      #$30,D3                 * determine data register value in ASCII
00001EEE  14C3                    1227              MOVE.B      D3,(A2)+                * push data register number into buffer
00001EF0  4EF8 1200               1228              JMP         prnttoscrn              * print out the buffer
00001EF4                          1229              
00001EF4  14FC 0020               1230  mani_ea     MOVE.B      #space,(A2)+            * add a space to buffer
00001EF8  43F9 000026A0           1231              LEA         bin_storage,A1          * re-initalize A1 to point to begining of storage
00001EFE  2419                    1232              MOVE.L      (A1)+,D2                * move bits from storage to D2
00001F00  2419                    1233              MOVE.L      (A1)+,D2                * move last 8 bits from storage to D2
00001F02  C4BC 00FFFFFF           1234              AND.L       #manip_mask8,D2         * isolate last 6 bits for ea
00001F08  4EB9 000020BA           1235              JSR         genEA                   * goto subroutine 'genEA'
00001F0E  4EF8 1200               1236              JMP         prnttoscrn              * print out the buffer
00001F12                          1237  ********************************************************************************
00001F12                          1238  * Description: Special Cases (nibble 4) - Aaron
00001F12                          1239  ********************************************************************************
00001F12  41F9 00002724           1240  specl_      LEA         spec_stor,A0            * load address register with storage
00001F18  3400                    1241              MOVE.W      D0,D2                   * copy word to temp register D2
00001F1A                          1242  
00001F1A  B07C 4D71               1243              CMP.W       #nop_opcode,D0          * check for NOP
00001F1E  6700 007A               1244              BEq         nop_                    * branch to "nop_" label
00001F22  B07C 4D75               1245              CMP.W       #rts_opcode,D0          * check for RTS
00001F26  6700 0080               1246              BEq         rts_                    * branch to "rts_" label
00001F2A  0282 00000100           1247              ANDI.L      #bit8_mask,D2           * isolate bit 8
00001F30  E08A                    1248              LSR.L       #8,D2                   * shift bit to the left
00001F32  0C02 0001               1249              CMPI.B      #1,D2                   * compare if 1 or 0
00001F36  6700 007E               1250              BEq         lea_                    * branch to "lea_" label
00001F3A  3400                    1251              MOVE.W      D0,D2                   * restore word from D0
00001F3C  0282 00000E00           1252              ANDI.L      #b911_mask,D2           * isolate bits 9 through 11
00001F42  E08A                    1253              LSR.L       #8,D2                   * shift bits
00001F44  E28A                    1254              LSR.L       #1,D2                   * shift one more
00001F46  0C02 0001               1255              CMPI.B      #1,D2                   * check if equal to 1
00001F4A  6700 00A4               1256              BEq         clr_                    * branch to "clr_" label
00001F4E  0C02 0002               1257              CMPI.B      #2,D2                   * check if equal to 2
00001F52  6700 00AC               1258              BEq         neg_                    * branch to "neg_" label
00001F56  0C02 0003               1259              CMPI.B      #3,D2                   * check if equal to 3
00001F5A  6700 00BA               1260              BEq         not_                    * branch to "not_" label
00001F5E  3400                    1261              MOVE.W      D0,D2                   * restore word from D0
00001F60  0282 00000038           1262              ANDI.L      #b35_mask,D2            * isolate bits 3 - 5 (EA mode)
00001F66  E68A                    1263              LSR.L       #3,D2                   * shift bits
00001F68  0C02 0000               1264              CMPI.B      #0,D2                   * check if equal to zero
00001F6C  6700 00BE               1265              BEq         swap_                   * branch to "swap_" label
00001F70  3400                    1266              MOVE.W      D0,D2                   * restore word from D0
00001F72  0282 00000200           1267              ANDI.L      #bit9_mask,D2           * isolate bit 9
00001F78  E08A                    1268              LSR.L       #8,D2                   * shift bits
00001F7A  E28A                    1269              LSR.L       #1,D2                   * shift twice more
00001F7C  0C02 0000               1270              CMPI.B      #0,D2                   * check if equal to 0
00001F80  6700 00D6               1271              BEq         movem_                  * branch to "movem_" label
00001F84  3400                    1272              MOVE.W      D0,D2                   * restore word from D0
00001F86  0282 00000040           1273              ANDI.L      #bit6_mask,D2           * isolate bit 6
00001F8C  EC8A                    1274              LSR.L       #6,D2                   * shift the bit
00001F8E  0C02 0000               1275              CMPI.B      #0,D2                   * check if equal to zero
00001F92  6700 00E6               1276              BEq         jsr_                    * branch to "jsr_" label
00001F96  6000 00F6               1277              BRA         jmp_                    * branch to "jmp_" label            
00001F9A                          1278                          
00001F9A  D1FC 00000014           1279  nop_        ADDA.L      #20,A0                  * add displacement to address
00001FA0  24D0                    1280              MOVE.L      (A0),(A2)+              * copy value from storage to buffer
00001FA2  4EF9 000020B6           1281              JMP         spc_done                * jump to end
00001FA8  D1FC 0000001C           1282  rts_        ADDA.L      #28,A0                  * add displacement to address
00001FAE  24D0                    1283              MOVE.L      (A0),(A2)+              * copy value from storage to buffer
00001FB0  4EF9 000020B6           1284              JMP         spc_done                * jump to end
00001FB6  D1FC 0000000C           1285  lea_        ADDA.L      #12,A0                  * add displacement to address
00001FBC  24D0                    1286              MOVE.L      (A0),(A2)+              * copy value from storage to buffer
00001FBE  24FC 20202020           1287              MOVE.L      #qspace,(A2)+           * add space to buffer
00001FC4  14FC 0024               1288              MOVE.B      #hex,(A2)+              * add $ to buffer
00001FC8  41F9 000026A0           1289              LEA         bin_storage,A0          * load address of storage
00001FCE  2418                    1290              MOVE.L      (A0)+,D2                * move long into D2
00001FD0  2418                    1291              MOVE.L      (A0)+,D2                * move next long into D2
00001FD2  0282 00FFFFFF           1292              ANDI.L      #manip_mask8,D2         * isolate EA bits
00001FD8  4EB9 000020BA           1293              JSR         genEA                   * generate Effective Address
00001FDE  3400                    1294              MOVE.W      D0,D2                   * restore word from D0
00001FE0  14FC 002C               1295              MOVE.B      #comma,(A2)+            * add , to buffer
00001FE4  4EB9 000023B2           1296              JSR         lea_reg                 * goto subroutine to determine register
00001FEA  4EF9 000020B6           1297              JMP         spc_done                * jump to end
00001FF0  24D0                    1298  clr_        MOVE.L      (A0),(A2)+              * copy value from storage to buffer
00001FF2  3400                    1299              MOVE.W      D0,D2                   * restore word from D0
00001FF4  4EB9 00002460           1300              JSR         getSize                 * goto subroutine to determine operator size
00001FFA  4EF9 000020A0           1301              JMP         spc_ea                  * jump to effective addressing
00002000  D1FC 00000010           1302  neg_        ADDA.L      #16,A0                  * add displacement to address
00002006  24D0                    1303              MOVE.L      (A0),(A2)+              * copy value from storage to buffer
00002008  3400                    1304              MOVE.W      D0,D2                   * restore word from D0
0000200A  4EB9 00002460           1305              JSR         getSize                 * goto subroutine to determine operator size
00002010  4EF9 000020A0           1306              JMP         spc_ea                  * jump to effective addressing
00002016  D1FC 00000018           1307  not_        ADDA.L      #24,A0                  * add displacement to address
0000201C  2490                    1308              MOVE.L      (A0),(A2)               * copy value from storage to buffer
0000201E  3400                    1309              MOVE.W      D0,D2                   * restore word from D0
00002020  4EB9 00002460           1310              JSR         getSize                 * goto subroutine to determine operator size
00002026  4EF9 000020A0           1311              JMP         spc_ea                  * jump to effective addressing
0000202C  D1FC 00000020           1312  swap_       ADDA.L      #32,A0                  * add displacement to address
00002032  24D0                    1313              MOVE.L      (A0),(A2)+              * copy value from storage to buffer
00002034  14FC 0020               1314              MOVE.B      #space,(A2)+            * add space to buffer
00002038  14FC 0020               1315              MOVE.B      #space,(A2)+            * add space to buffer
0000203C  14FC 0020               1316              MOVE.B      #space,(A2)+            * add space to buffer
00002040  14FC 0044               1317              MOVE.B      #$44,(A2)+              * add D to buffer
00002044  3400                    1318              MOVE.W      D0,D2                   * restore word from D0
00002046  0282 00000007           1319              ANDI.L      #swap_mask,D2           * isolate register size
0000204C  0602 0030               1320              ADDI.B      #$30,D2                 * convert to ascii
00002050  14C2                    1321              MOVE.B      D2,(A2)+                * copy ascii value to buffer
00002052  4EF9 000020B6           1322              JMP         spc_done                * jump to end
00002058  41F9 0000271C           1323  movem_      LEA         move_stor,A0            * load storage for 'move'
0000205E  24D0                    1324              MOVE.L      (A0),(A2)+              * copy value from storage to buffer
00002060  14FC 004D               1325              MOVE.B      #$4D,(A2)+              * add "M" to buffer
00002064  14FC 0020               1326              MOVE.B      #space,(A2)+            * add a space to buffer
00002068  14FC 0020               1327              MOVE.B      #space,(A2)+            * add a space to buffer 
0000206C  3400                    1328              MOVE.W      D0,D2                   * restore word from D0
0000206E  4EB9 00002440           1329              JSR         movemsr                 * goto "movemsr" subroutine
00002074  4EF9 000020B6           1330              JMP         spc_done                * jump to end
0000207A  5888                    1331  jsr_        ADDA.L      #4,A0                   * add displacement to address
0000207C  24D0                    1332              MOVE.L      (A0),(A2)+              * copy value from storage to buffer
0000207E  24FC 20202020           1333              MOVE.L      #qspace,(A2)+           * add space to buffer
00002084  14FC 0024               1334              MOVE.B      #hex,(A2)+              * add $ to buffer
00002088  4EF9 000020A0           1335              JMP         spc_ea                  * jump to effective addressing
0000208E  5088                    1336  jmp_        ADDA.L      #8,A0                   * add displacement to address
00002090  24D0                    1337              MOVE.L      (A0),(A2)+              * copy value from storage to buffer
00002092  14FC 0020               1338              MOVE.B      #space,(A2)+            * add space to buffer
00002096  14FC 0020               1339              MOVE.B      #space,(A2)+            * add space to buffer
0000209A  4EB9 000020A0           1340              JSR         spc_ea                  * generate Effective Address
000020A0  41F9 000026A0           1341  spc_ea      LEA         bin_storage,A0          * load address of storage
000020A6  2418                    1342              MOVE.L      (A0)+,D2                * move long into D2
000020A8  2418                    1343              MOVE.L      (A0)+,D2                * move next long into D2
000020AA  0282 00FFFFFF           1344              ANDI.L      #manip_mask8,D2         * isolate EA bits
000020B0  4EB9 000020BA           1345              JSR         genEA                   * generate Effective Address
000020B6  4EF8 1200               1346  spc_done    JMP         prnttoscrn              * jump to printer                               
000020BA                          1347  ********************************************************************************    
000020BA                          1348  *                                                                              *
000020BA                          1349  *                              SUBROUTINES                                     *
000020BA                          1350  *                                                                              *
000020BA                          1351  ********************************************************************************    
000020BA                          1352  *-------------------------------------------------------------------------------
000020BA                          1353  * Subroutine: genEA
000020BA                          1354  * Description: Will generate the proper Effective Address the last six bits in
000020BA                          1355  *              stored in D2
000020BA                          1356  * API:      A0 - points to binary pattern storage
000020BA                          1357  *           A2 - pointer to good_buffer 
000020BA                          1358  *           D2 - contains six bits for effective addressing
000020BA                          1359  *           D3 - holds register number
000020BA                          1360  *           D7 - holds mode      
000020BA                          1361  *-------------------------------------------------------------------------------
000020BA  7600                    1362  genEA       MOVE.L      #empty,D3               * clear register
000020BC  7E00                    1363              MOVE.L      #empty,D7               * clear register
000020BE  2E02                    1364              MOVE.L      D2,D7                   * copy to temp location
000020C0  0287 00FFF000           1365              ANDI.L      #ea_mask1,D7            * isolate mode
000020C6  E08F                    1366              LSR.L       #8,D7                   * shift some
000020C8  E88F                    1367              LSR.L       #4,D7                   * shift more
000020CA  C4BC 00000FFF           1368              AND.L       #ea_mask2,D2            * isolate register
000020D0  41F9 00002680           1369              LEA         bin_pattern,A0          * re-initalize A0 to point to begining of patterns
000020D6  4EB9 000023A6           1370              JSR         bin_to_dec              * convert value in D2 to decimal
000020DC  0603 0030               1371              ADDI.B      #$30,D3                 * determine data register value in ASCII
000020E0                          1372  
000020E0  BE7C 0000               1373              CMP.W       #mode0,D7               * is equal to zero
000020E4  6700 0040               1374              BEq         mode_dn                 * branch to data register
000020E8  BE7C 0001               1375              CMP.W       #mode1,D7               * is equal to one
000020EC  6700 0044               1376              BEq         mode_an                 * branch to address register
000020F0  BE7C 0010               1377              CMP.W       #mode2,D7               * is equal to two
000020F4  6700 0048               1378              BEq         mode_anin               * branch to address indirect
000020F8  BE7C 0011               1379              CMP.W       #mode3,D7               * is equal to three
000020FC  6700 0054               1380              BEq         mode_anplus             * branch to address register post-increment
00002100  BE7C 0100               1381              CMP.W       #mode4,D7               * is equal to four
00002104  6700 0064               1382              BEq         mode_andec              * branch to address register pre-decrement
00002108  BE7C 0110               1383              CMP.W       #mode6,D7               * is equal to five
0000210C  6700 0074               1384              BEq         mode_aninx              * branch to address indirect with index
00002110  BE7C 0111               1385              CMP.W       #mode7,D7               * is equal to seven
00002114  6700 008A               1386              BEq         mode_svn                * branch to mode seven
00002118  13FC 00FF 0000267F      1387              MOVE.B      #bad,flag               * set flag to bad
00002120  4EF9 000021A6           1388              JMP         genEA_done              * jump to end
00002126                          1389              
00002126  14FC 0044               1390  mode_dn     MOVE.B      #$44,(A2)+              * add 'D' to buffer
0000212A  14C3                    1391              MOVE.B      D3,(A2)+                * copy register number to buffer
0000212C  4EF9 000021A6           1392              JMP         genEA_done              * jump to end of subroutine
00002132  14FC 0041               1393  mode_an     MOVE.B      #$41,(A2)+              * add 'A' to buffer
00002136  14C3                    1394              MOVE.B      D3,(A2)+                * copy register number to buffer
00002138  4EF9 000021A6           1395              JMP         genEA_done              * jump to end of subroutine
0000213E  14FC 0028               1396  mode_anin   MOVE.B      #opp,(A2)+              * add '(' to buffer
00002142  14FC 0041               1397              MOVE.B      #$41,(A2)+              * add 'A' to buffer
00002146  14C3                    1398              MOVE.B      D3,(A2)+                * copy register number to buffer
00002148  14FC 0029               1399              MOVE.B      #clp,(A2)+              * add ')' to buffer
0000214C  4EF9 000021A6           1400              JMP         genEA_done              * jump to end of subroutine
00002152  14FC 0028               1401  mode_anplus MOVE.B      #opp,(A2)+              * add '(' to buffer
00002156  14FC 0041               1402              MOVE.B      #$41,(A2)+              * add 'A' to buffer
0000215A  14C3                    1403              MOVE.B      D3,(A2)+                * copy register number to buffer
0000215C  14FC 0029               1404              MOVE.B      #clp,(A2)+              * add ')' to buffer
00002160  14FC 002B               1405              MOVE.B      #plus,(A2)+             * add '+' to buffer
00002164  4EF9 000021A6           1406              JMP         genEA_done              * jump to end of subroutine
0000216A  14FC 002D               1407  mode_andec  MOVE.B      #minus,(A2)+            * add '-' to buffer
0000216E  14FC 0028               1408              MOVE.B      #opp,(A2)+              * add '(' to buffer
00002172  14FC 0041               1409              MOVE.B      #$41,(A2)+              * add 'A' to buffer
00002176  14C3                    1410              MOVE.B      D3,(A2)+                * copy register number to buffer
00002178  14FC 0029               1411              MOVE.B      #clp,(A2)+              * add ')' to buffer
0000217C  4EF9 000021A6           1412              JMP         genEA_done              * jump to end of subroutine
00002182  14FC 0028               1413  mode_aninx  MOVE.B      #opp,(A2)+              * add '(' to buffer
00002186  14FC 0024               1414              MOVE.B      #hex,(A2)+              * add '$' to buffer
0000218A  34DC                    1415              MOVE.W      (A4)+,(A2)+             * add word to buffer
0000218C  14FC 002C               1416              MOVE.B      #comma,(A2)+            * add ',' to buffer
00002190  14FC 0041               1417              MOVE.B      #$41,(A2)+              * add 'A' to buffer
00002194  14C3                    1418              MOVE.B      D3,(A2)+                * copy register number of buffer
00002196  14FC 0029               1419              MOVE.B      #clp,(A2)+              * add ')' to buffer     
0000219A  4EF9 000021A6           1420              JMP         genEA_done              * jump to end of subroutine
000021A0  4EB9 000021A8           1421  mode_svn    JSR         submodesvn              * subroutine 'submodesvn'           
000021A6  4E75                    1422  genEA_done  RTS
000021A8                          1423  *-------------------------------------------------------------------------------
000021A8                          1424  * Subroutine: submodesvn
000021A8                          1425  * Description: Will use value in register to determine if immediate word, long,
000021A8                          1426  *              or immediate data.
000021A8                          1427  * D2 contains six bits or ea (mode / register)
000021A8                          1428  *
000021A8                          1429  * API:      A2 - pointer to good_buffer
000021A8                          1430  *           D3 - register value (decimal) / stores word read from memory
000021A8                          1431  *           D7 - temp storage for word stored in D0      
000021A8                          1432  *-------------------------------------------------------------------------------
000021A8  0403 0030               1433  submodesvn  SUBI.B      #$30,D3                 * subtract 30 from value
000021AC  3E00                    1434              MOVE.W      D0,D7                   * copy word to D7
000021AE  B63C 0000               1435              CMP.B       #reg0,D3                * compare D3 to 000
000021B2  6700 005E               1436              BEq         reg_word                * branch if register is 000
000021B6  B63C 0001               1437              CMP.B       #reg1,D3                * compare D3 to 001
000021BA  6700 0014               1438              BEq         reg_long                * branch if register is 001
000021BE  B63C 0004               1439              CMP.B       #reg4,D3                * compare D3 to 100
000021C2  6700 0072               1440              BEq         reg_four                * branch if register is 100
000021C6  1CBC 00FF               1441              MOVE.B      #bad,(A6)               * set bad flag
000021CA  4EF9 00002274           1442              JMP         sms_done                * jump to end
000021D0  3014                    1443  reg_long    MOVE.W      (A4),D0                 * move the <data> MUST CHANGE TO (A4),D0
000021D2  C0BC 0000FF00           1444              AND.L       #hToAMask_1,D0          * isolate left byte of word
000021D8  E088                    1445              LSR.L       #8,D0                   * shift byte to least sig digit
000021DA  4EB9 0000234E           1446              JSR         hexToA                  * convert hex values to ascii for buffer
000021E0  301C                    1447              MOVE.W      (A4)+,D0                * move the <data> MUST CHANGE TO (A4)+,D0
000021E2  C0BC 000000FF           1448              AND.L       #hToAMask_2,D0          * isolate right  byte of word
000021E8  4EB9 0000234E           1449              JSR         hexToA                  * convert hex values to ascii for buffer
000021EE  3014                    1450              MOVE.W      (A4),D0                 * move the <data> MUST CHANGE TO (A4),D0
000021F0  C0BC 0000FF00           1451              AND.L       #hToAMask_1,D0          * isolate left byte of word
000021F6  E088                    1452              LSR.L       #8,D0                   * shift byte to least sig digit
000021F8  4EB9 0000234E           1453              JSR         hexToA                  * convert hex values to ascii for buffer
000021FE  301C                    1454              MOVE.W      (A4)+,D0                * move the <data> MUST CHANGE TO (A4)+,D0
00002200  C0BC 000000FF           1455              AND.L       #hToAMask_2,D0          * isolate right  byte of word
00002206  4EB9 0000234E           1456              JSR         hexToA                  * convert hex values to ascii for buffer
0000220C  4EF9 00002274           1457              JMP         sms_done                * jump to end
00002212  3014                    1458  reg_word    MOVE.W      (A4),D0                 * move the <data> MUST CHANGE TO (A4),D0
00002214  C0BC 0000FF00           1459              AND.L       #hToAMask_1,D0          * isolate left byte of word
0000221A  E088                    1460              LSR.L       #8,D0                   * shift byte to least sig digit
0000221C  4EB9 0000234E           1461              JSR         hexToA                  * convert hex values to ascii for buffer
00002222  301C                    1462              MOVE.W      (A4)+,D0                * move the <data> MUST CHANGE TO (A4)+,D0
00002224  C0BC 000000FF           1463              AND.L       #hToAMask_2,D0          * isolate right  byte of word
0000222A  4EB9 0000234E           1464              JSR         hexToA                  * convert hex values to ascii for buffer
00002230  4EF9 00002274           1465              JMP         sms_done                * jump to end
00002236  14FC 0023               1466  reg_four    MOVE.B      #num,(A2)+              * add # to buffer
0000223A  14FC 0024               1467              MOVE.B      #hex,(A2)+              * add $ to buffer
0000223E  301C                    1468              MOVE.W      (A4)+,D0                * copy word to register D0
00002240  3400                    1469              MOVE.W      D0,D2                   * copy word to register D2
00002242  0242 FF00               1470              ANDI.W      #$FF00,D2               * isolate last two bits
00002246  E08A                    1471              LSR.L       #8,D2                   * shift bits to LSB position
00002248  0C02 0000               1472              CMPI.B      #0,D2                   * check if zero
0000224C  6700 0008               1473              BEq         rf_next                 * check next bits
00002250  4EB9 0000234E           1474              JSR         hexToA                  * convert byte to ascii
00002256  3400                    1475  rf_next     MOVE.W      D0,D2                   * restore word in D2
00002258  0242 00FF               1476              ANDI.W      #$00FF,D2               * isolate first two bits
0000225C  0C02 0000               1477              CMPI.B      #0,D2                   * check if zero
00002260  6700 000E               1478              BEq         rf_zero_                * branch to label
00002264  4EB9 0000234E           1479              JSR         hexToA                  * convert to ascii
0000226A  4EF9 00002274           1480              JMP         sms_done                * jump to end
00002270  14FC 0030               1481  rf_zero_    MOVE.B      #$30,(A2)+              * add 0 to buffer         
00002274  4E75                    1482  sms_done    RTS
00002276                          1483  *-------------------------------------------------------------------------------
00002276                          1484  * Subroutine: appends
00002276                          1485  * Description: Used to append either an 'L', 'W', or 'B' to the print buffer
00002276                          1486  * API: A2
00002276                          1487  *      D3 - 
00002276                          1488  *-------------------------------------------------------------------------------
00002276  B63C 0000               1489  appends     CMP.B       #$0,D3      * hex value == 0?
0000227A  6700 001A               1490              BEQ         isbyte      * yes, so it's a byte
0000227E  B63C 0001               1491              CMP.B       #$1,D3      * hex value == 1?
00002282  6700 001A               1492              BEQ         isword      * yes, so it's a word
00002286  B63C 0002               1493              CMP.B       #$2,D3      * hex value == 2
0000228A  6700 0002               1494              BEQ         islong      * yes, so it's a long
0000228E  14FC 004C               1495  islong      MOVE.B      #$4C,(A2)+  * move ASCII value for 'L' to buffer
00002292  6000 000E               1496              BRA         app_done    * get out of SR
00002296  14FC 0042               1497  isbyte      MOVE.B      #$42,(A2)+  * move ASCII value for 'B' to buffer
0000229A  6000 0006               1498              BRA         app_done    * get out of sr
0000229E  14FC 0057               1499  isword      MOVE.B      #$57,(A2)+  * move ASCII value for 'W' to buffer
000022A2  4E75                    1500  app_done    RTS                     * get out of subroutine
000022A4                          1501  *-------------------------------------------------------------------------------
000022A4                          1502  * Subroutine: isValid
000022A4                          1503  * Description: Will validate a user inputted addresses
000022A4                          1504  * API: A0 - used internally to store address being tested
000022A4                          1505  *      A1 - used internally for Trap statement (pointer to error)
000022A4                          1506  *      D0 - used internally for Trap statement (display error)
000022A4                          1507  *      D1 - used internally for Trap statement (error length)
000022A4                          1508  *      D7 - used as a flag ($00000000 == good ; !0 == bad
000022A4                          1509  *-------------------------------------------------------------------------------
000022A4  4E71                    1510  isValid     NOP
000022A6  2047                    1511              MOVEA.L     D7,A0                   * copy address to register A0
000022A8  B1FC 00001000           1512              CMP.L       #start_bnds,A0          * compare starting address to lower bounds
000022AE  6C00 0018               1513              BGE         check_2                 * branch to 'check_2' if valid
000022B2  103C 0001               1514              MOVE.B      #tsk1,D0                * load task
000022B6  43F9 00002B66           1515              LEA         error1,A1               * get address of string
000022BC  323C 2B98               1516              MOVE.W      #e_len1,D1              * get length of string
000022C0  4E4F                    1517              TRAP        #15                     * display error
000022C2  4EF9 000022EA           1518              JMP         set_bad                 * jump to 'set_bad'
000022C8  B1FC 000FFFFF           1519  check_2     CMPA.L      #end_bnds,A0            * compare ending address to upperbounds
000022CE  6D00 0018               1520              BLT         set_good                * branch to next 'set_good' if valid
000022D2  103C 0001               1521              MOVE.B      #tsk1,D0                * load task
000022D6  43F9 00002B9A           1522              LEA         error2,A1               * get address of string
000022DC  323C 2BCA               1523              MOVE.W      #e_len2,D1              * get length of string
000022E0  4E4F                    1524              TRAP        #15                     * display error
000022E2  4EF9 000022EA           1525              JMP         set_bad                 * jump to 'set_bad'
000022E8  7E00                    1526  set_good    MOVE.L      #empty,D7               * clear register / set flag
000022EA  4E75                    1527  set_bad     RTS                                 * return to program main            
000022EC                          1528  *-------------------------------------------------------------------------------
000022EC                          1529  * Subroutine: convert
000022EC                          1530  * Description: Will convert the ascii pattern found at the storage
000022EC                          1531  *              pointed to by A3 to hex digits. Conversion is done
000022EC                          1532  *              on a character by character basis.
000022EC                          1533  *              Initialization of registers occurs before subroutine.
000022EC                          1534  *              Because of this, no need to push any registers to the
000022EC                          1535  *              stack.
000022EC                          1536  *              NOTE: there is no error checking in this subroutine as
000022EC                          1537  *              per assignment parameters.
000022EC                          1538  * API: A3 - starting address of storage with user input
000022EC                          1539  *      D1 - length of user input
000022EC                          1540  *      D6 - storage for each ascii code read
000022EC                          1541  *      D7 - storage for converted characters
000022EC                          1542  *-------------------------------------------------------------------------------
000022EC  13FC 0000 0000267D      1543  convert     MOVE.B      #reset,counter          * reset counter to zero
000022F4  B239 0000267D           1544  lloop       CMP.B       counter,D1              * compare counter to length
000022FA  6F00 004A               1545              BLE         cnvt_done               * ascii translated?                             
000022FE  1C1B                    1546              MOVE.B      (A3)+,D6                * load data register
00002300  BC3C 0057               1547              CMP.B       #l_key,D6               * compare key to data   
00002304  6F00 0014               1548              BLE         uloop                   * branch to lowercase?
00002308  E987                    1549              ASL.L       #shift,D7               * need to know how to shift correctly
0000230A  0406 0057               1550              SUBI.B      #l_key,D6               * subtract l_key value
0000230E  8E06                    1551              OR.B        D6,D7                   * isolate bits and combine
00002310  5239 0000267D           1552              ADDQ.B      #increment,counter      * increment counter
00002316  4EF8 22F4               1553              JMP         lloop                   * jump to 'lloop'
0000231A                          1554              
0000231A  BC3C 0040               1555  uloop       CMP.B       #$40,D6                 * is number?
0000231E  6F00 0014               1556              BLE         nloop                   * branch to nloop
00002322  E987                    1557              ASL.L       #shift,D7               * need to know how to shift correctly
00002324  0406 0037               1558              SUBI.B      #u_key,D6               * subtract u_key value
00002328  8E06                    1559              OR.B        D6,D7                   * isolate bits and combine
0000232A  5239 0000267D           1560              ADDQ.B      #increment,counter      * increment counter
00002330  4EF8 22F4               1561              JMP         lloop                   * jump to 'lloop'
00002334                          1562  
00002334  E987                    1563  nloop       ASL.L       #shift,D7               * need to know how to shift correctly           
00002336  0406 0030               1564              SUBI.B      #n_key,D6               * subtract n_key value
0000233A  8E06                    1565              OR.B        D6,D7                   * isolate bits and combine
0000233C  5239 0000267D           1566              ADDQ.B      #increment,counter      * increment counter
00002342  4EF8 22F4               1567              JMP         lloop                   * jump to 'lloop'
00002346                          1568  
00002346  CEBC FFFFFFFE           1569  cnvt_done   AND.L       #mask_even,D7           * make address even if odd
0000234C  4E75                    1570              RTS                                 * return to program main            
0000234E                          1571  *-------------------------------------------------------------------------------
0000234E                          1572  * Subroutine: hexToA
0000234E                          1573  * Description: Will convert the bad address location, the pattern
0000234E                          1574  *              written, and the pattern read from hex values to
0000234E                          1575  *              ascii values.  This has to be done in order to
0000234E                          1576  *              print out this information to screen.  The ascii
0000234E                          1577  *              values are stored in a print buffer which is pointed
0000234E                          1578  *              to by A4.
0000234E                          1579  * API: A2 - points to good_buffer
0000234E                          1580  *      A3 - byte currently being converted
0000234E                          1581  *      A4 - points to print buffer, places converted ASCII into buffer
0000234E                          1582  *      D4 - holds current byte being converted
0000234E                          1583  *      D6 - holds left nibble of byte being converted
0000234E                          1584  *      D5 - holds right nibble of byte being converted
0000234E                          1585  *-------------------------------------------------------------------------------
0000234E  13FC 0001 0000267D      1586  hexToA      MOVE.B      #$1,counter             * set counter
00002356  0C39 0000 0000267D      1587  hexToAJmp   CMP.B       #0,counter              * see if counter is 0
0000235E  6700 0044               1588              BEQ         getout                  * done converting, exit sub routine
00002362  5339 0000267D           1589              SUBQ.B      #1,counter              * subtract 1 from counter
00002368                          1590                          
00002368  2C3C 000000F0           1591              MOVE.L      #mask_left,D6           * mask used to isolate left nibble  
0000236E  7A0F                    1592              MOVE.L      #mask_right,D5          * mask used to isolate right nibble
00002370  CC80                    1593              AND.L       D0,D6                   * logical AND of left nibble w/ mask
00002372  E88E                    1594              LSR.L       #shift,D6               * shift to the right once
00002374  BC3C 000A               1595              CMP.B       #$0A,D6                 * value being converted is a number?
00002378  6C00 001A               1596              BGE         letr_conv               * no, it's a letter, branch
0000237C  0606 0030               1597              ADDI.B      #$30,D6                 * yes, it's a number, add 30 to get ASCII
00002380  14C6                    1598              MOVE.B      D6,(A2)+                * push into print buffer
00002382                          1599              
00002382  CA80                    1600  r_nib       AND.L       D0,D5                   * logical AND of right nibble w/ mask                       
00002384  BA3C 000A               1601              CMP.B       #$0A,D5                 * value being converted is a number?
00002388  6C00 0012               1602              BGE         letr_conv2              * no, it's a letter, branch
0000238C  0605 0030               1603              ADDI.B      #$30,D5                 * yes, it's a number, add 30 to get ASCII
00002390  14C5                    1604              MOVE.B      D5,(A2)+                * push into print buffer
00002392  60C2                    1605              BRA         hexToAJmp               * loop to continue converting
00002394                          1606              
00002394  0606 0037               1607  letr_conv   ADDI.B      #$37,D6                 * add 37 to get ASCII value
00002398  14C6                    1608              MOVE.B      D6,(A2)+                * push into print buffer
0000239A  60E6                    1609              BRA         r_nib                   * branch to convert right nibble
0000239C                          1610              
0000239C  0605 0037               1611  letr_conv2  ADDI.B      #$37,D5                 * add 37 to get ASCII value
000023A0  14C5                    1612              MOVE.B      D5,(A2)+                * push right nibble to print buffer
000023A2  60B2                    1613              BRA         hexToAJmp               * loop to continue converting
000023A4                          1614              
000023A4  4E75                    1615  getout      RTS                                 * exit from this subroutine
000023A6                          1616  *-------------------------------------------------------------------------------
000023A6                          1617  * Subroutine: bin_to_dec
000023A6                          1618  * Description:
000023A6                          1619  * API: D2 - 
000023A6                          1620  *      D3 - 
000023A6                          1621  * subroutine bin_to_dec - used to convert binary to decimal
000023A6                          1622  *-------------------------------------------------------------------------------
000023A6  B458                    1623  bin_to_dec  CMP.W       (A0)+,D2
000023A8  6700 0006               1624              BEQ         btd_done
000023AC  5243                    1625              ADDQ.W      #1,D3
000023AE  60F6                    1626              BRA         bin_to_dec
000023B0  4E75                    1627  btd_done    RTS
000023B2                          1628  *-------------------------------------------------------------------------------
000023B2                          1629  * Subroutine:  lea_reg
000023B2                          1630  * Description: Will isolate bits 9 - 11 to determine which register is will be
000023B2                          1631  *              loaded with the effective address.  Note: If result is 7 (111),
000023B2                          1632  *              SP, not An will be written to the buffer.
000023B2                          1633  * API:      A2 - pointer to good buffer
000023B2                          1634  *           D2 - Binary pattern for word
000023B2                          1635  *-------------------------------------------------------------------------------
000023B2  0282 00000E00           1636  lea_reg     ANDI.L      #b911_mask,D2           * isolate bits 9 - 11 (register number)
000023B8  E08A                    1637              LSR.L       #8,D2                   * shift bits
000023BA  E28A                    1638              LSR.L       #1,D2                   * shift one more
000023BC  0C02 0007               1639              CMPI.B      #7,D2                   * check if equal to seven
000023C0  6700 0012               1640              BEq         sp_size                 * branch to "sp_size" label
000023C4  14FC 0041               1641              MOVE.B      #$41,(A2)+              * add A to buffer
000023C8  0602 0030               1642              ADDI.B      #$30,D2                 * change to ascii value
000023CC  14C2                    1643              MOVE.B      D2,(A2)+                * copy ascii value to buffer
000023CE  4EF9 000023DC           1644              JMP         lr_done                 * jump to end
000023D4  14FC 0053               1645  sp_size     MOVE.B      #$53,(A2)+              * add S to buffer
000023D8  14FC 0050               1646              MOVE.B      #$50,(A2)+              * add P to buffer
000023DC  4E75                    1647  lr_done     RTS                                 * return from subroutine
000023DE                          1648  *-------------------------------------------------------------------------------
000023DE                          1649  * Subroutine:  movesr
000023DE                          1650  * Description: Will generate <ea>,<ea> for MOVE
000023DE                          1651  * API:      A2 - pointer to good_buffer
000023DE                          1652  *           D0 - word read from memory
000023DE                          1653  *           D1 - copy of word
000023DE                          1654  *-------------------------------------------------------------------------------
000023DE  41F9 000026A0           1655  movesr      LEA         bin_storage,A0          * load storage
000023E4  2418                    1656              MOVE.L      (A0)+,D2                * read in byte
000023E6  2418                    1657              MOVE.L      (A0)+,D2                * move next long into D2
000023E8  0282 00FFFFFF           1658              ANDI.L      #manip_mask8,D2         * isolate EA bits
000023EE  4EB8 20BA               1659              JSR         genEA                   * generate source Effective Address
000023F2  14FC 002C               1660              MOVE.B      #comma,(A2)+            * add , to buffer
000023F6  41F9 000026A0           1661              LEA         bin_storage,A0          * load storage
000023FC  3418                    1662              MOVE.W      (A0)+,D2                * read in word
000023FE  2418                    1663              MOVE.L      (A0)+,D2                * move next long into D2
00002400  0282 FFFFFF00           1664              ANDI.L      #gen_mask,D2            * isolate EA bits
00002406  4EB8 20BA               1665              JSR         genEA                   * generate destination Effective Address
0000240A  4EF8 1200               1666              JMP         prnttoscrn              * jump to printer
0000240E                          1667  *-------------------------------------------------------------------------------
0000240E                          1668  * Subroutine:  moveasr
0000240E                          1669  * Description: Will generate <ea>,An for MOVEA
0000240E                          1670  * API:      A2 - pointer to good_buffer
0000240E                          1671  *           D0 - word read from memory
0000240E                          1672  *           D1 - copy of word
0000240E                          1673  *-------------------------------------------------------------------------------
0000240E  41F9 000026A0           1674  moveasr     LEA         bin_storage,A0          * load storage
00002414  3418                    1675              MOVE.W      (A0)+,D2                * read in word
00002416  2418                    1676              MOVE.L      (A0)+,D2                * move next long into D2
00002418  0282 FFFFFF00           1677              ANDI.L      #gen_mask,D2            * isolate EA bits
0000241E  E08A                    1678              LSR.L       #8,D2                   * shift bits to LSB position
00002420  4EB8 20BA               1679              JSR         genEA                   * generate Effective Address
00002424  0280 00000E00           1680              ANDI.L      #b911_mask,D0           * isolate bits 9 - 11 (register number)
0000242A  E088                    1681              LSR.L       #8,D0                   * shift bits towards LSB position
0000242C  E288                    1682              LSR.L       #1,D0                   * shift one more
0000242E  0600 0030               1683              ADDI.B      #$30,D0                 * convert number to ascii
00002432  14FC 002C               1684              MOVE.B      #comma,(A2)+            * add , to buffer
00002436  14FC 0041               1685              MOVE.B      #$41,(A2)+              * add A to buffer
0000243A  14C0                    1686              MOVE.B      D0,(A2)+                * add number to buffer
0000243C  4EF8 1200               1687              JMP         prnttoscrn              * jump to printer
00002440                          1688  *-------------------------------------------------------------------------------
00002440                          1689  * Subroutine: movemsr
00002440                          1690  * Description: MOVEM Subroutine
00002440                          1691  *              This is a "helper" subroutine for MOVEM to generate the register
00002440                          1692  *              list and the order in which it's printed to the screen.
00002440                          1693  *              
00002440                          1694  * API:      A0 - used internally as pointer to string storage
00002440                          1695  *           A2 - pointer to 'good' buffer
00002440                          1696  *           D2 - holds binary world value
00002440                          1697  *-------------------------------------------------------------------------------
00002440  0282 00000400           1698  movemsr     ANDI.L      #movm_mask,D2           * isolate bit 10
00002446  E08A                    1699              LSR.L       #8,D2                   * shift bit
00002448  E48A                    1700              LSR.L       #2,D2                   * shift more
0000244A  0C02 0000               1701              CMPI.B      #0,D2                   * check if register to memory
0000244E  6700 0008               1702              BEq         reg2mem                 * branch to label
00002452  4EF9 0000245E           1703              JMP         mem2reg                 * branch to label
00002458                          1704  reg2mem     * code here
00002458  4EF9 0000245E           1705              JMP         mmsr_done               * jump to end
0000245E                          1706  mem2reg     * code here 
0000245E  4E75                    1707  mmsr_done   RTS                                 * return from subroutine
00002460                          1708  *-------------------------------------------------------------------------------
00002460                          1709  * Subroutine:  getSize
00002460                          1710  * Description: Will isolate bits 6 and 7 to determine the size of the op code
00002460                          1711  *              operation.
00002460                          1712  *              00 - Byte
00002460                          1713  *              01 - Word
00002460                          1714  *              10 - Long
00002460                          1715  *              11 - error (set bad flag)
00002460                          1716  * API:      A2 - pointer to good buffer
00002460                          1717  *           D2 - binary pattern for word
00002460                          1718  *-------------------------------------------------------------------------------
00002460  2411                    1719  getSize     MOVE.L      (A1),D2                 * restore bits from storage
00002462  0282 000000C0           1720              ANDI.L      #size_mask,D2           * isolate size bits
00002468  EC8A                    1721              LSR.L       #6,D2                   * shift bits
0000246A  0C02 0000               1722              CMPI.B      #0,D2                   * check if equal to zero (byte)
0000246E  6700 001A               1723              BEq         gs_b                    * branch to byte
00002472  0C02 0001               1724              CMPI.B      #1,D2                   * check if equal to one (word)
00002476  6700 001C               1725              BEq         gs_w                    * branch to word
0000247A  0C02 0002               1726              CMPI.B      #2,D2                   * check if equal to two (long)
0000247E  6700 001E               1727              BEq         gs_l                    * branch to long
00002482  1CBC 00FF               1728              MOVE.B      #bad,(A6)               * set bad flag
00002486  4EF8 1200               1729              JMP         prnttoscrn              * jump to printer
0000248A  14FC 0042               1730  gs_b        MOVE.B      #byte,(A2)+             * add B to buffer
0000248E  4EF9 000024A2           1731              JMP         gs_done                 * jump to effective addressing
00002494  14FC 0057               1732  gs_w        MOVE.B      #word,(A2)+             * add W to buffe
00002498  4EF9 000024A2           1733              JMP         gs_done                 * jump to effective addressing
0000249E  14FC 004C               1734  gs_l        MOVE.B      #long,(A2)+             * add L to buffer
000024A2  14FC 0020               1735  gs_done     MOVE.B      #space,(A2)+            * add space to buffer
000024A6  14FC 0020               1736              MOVE.B      #space,(A2)+            * add space to buffer
000024AA  4E75                    1737              RTS                                 * return from subroutine
000024AC                          1738  *-------------------------------------------------------------------------------
000024AC                          1739  * Subroutine:  setBuffers
000024AC                          1740  * Description: Will clear buffers by filling buffers with spaces (in ascii).
000024AC                          1741  *              Then will initialize buffers with the following:
000024AC                          1742  *              GOOD_BUFFER
000024AC                          1743  *              xxxxxxxx_(x represents address)
000024AC                          1744  *              BAD_BUFFER
000024AC                          1745  *              xxxxxxxx_DATA_$wwww$0A,$0D
000024AC                          1746  *
000024AC                          1747  *              At the end of the subroutine, A1 will point to good_buffer, A2 and
000024AC                          1748  *              A3 will be cleared as well as the counter
000024AC                          1749  * API:      A0 - pointer to storage
000024AC                          1750  *           A1 - pointer to the good buffer
000024AC                          1751  *           A2 - pointer to the bad buffer
000024AC                          1752  *           A3 - pointer to counter
000024AC                          1753  *           A4 - current address
000024AC                          1754  *           D0 - copy of current address
000024AC                          1755  *-------------------------------------------------------------------------------
000024AC  43F9 00002748           1756  setBuffers  LEA         good_buffer,A1          * load register with good buffer
000024B2  45F9 0000279A           1757              LEA         bad_buffer,A2           * load register with bad buffer
000024B8  47F9 0000267D           1758              LEA         counter,A3              * load register with counter
000024BE  0C39 0050 0000267D      1759  sb_clr      CMPI.B      #80,counter             * check if counter is 80
000024C6  6C00 0010               1760              BGE         sb_next                 * branch to next stage
000024CA  12FC 0020               1761              MOVE.B      #space,(A1)+            * write space to buffer
000024CE  14FC 0020               1762              MOVE.B      #space,(A2)+            * write space to buffer
000024D2  5213                    1763              ADDI.B      #increment,(A3)         * increment counter
000024D4  4EF8 24BE               1764              JMP         sb_clr                  * goto top of loop
000024D8                          1765              
000024D8  16BC 0000               1766  sb_next     MOVE.B      #reset,(A3)             * clear counter
000024DC  45F9 00002748           1767              LEA         good_buffer,A2          * reload good_buffer
000024E2  200C                    1768              MOVE.L      A4,D0                   * copy address to data register
000024E4  0280 FF000000           1769  byte_4      ANDI.L      #mask_byte1,D0          * isolate byte four
000024EA  E198                    1770              ROL.L       #8,D0                   * shift to LSB position
000024EC  4EB8 234E               1771              JSR         hexToA                  * convert byte and copy to buffer
000024F0  200C                    1772  byte_3      MOVE.L      A4,D0                   * restore address copy
000024F2  0280 00FF0000           1773              ANDI.L      #mask_byte2,D0          * isolate byte three
000024F8  E198                    1774              ROL.L       #8,D0                   * shift toward LSB position
000024FA  E198                    1775              ROL.L       #8,D0                   * shift again
000024FC  4EB8 234E               1776              JSR         hexToA                  * convert byte and copy to buffer
00002500  200C                    1777  byte_2      MOVE.L      A4,D0                   * restore address copy
00002502  0280 0000FF00           1778              ANDI.L      #mask_byte3,D0          * isolate byte two
00002508  E098                    1779              ROR.L       #8,D0                   * shift to LSB position
0000250A  4EB8 234E               1780              JSR         hexToA                  * convert byte and copy to buffer
0000250E  200C                    1781  byte_1      MOVE.L      A4,D0                   * restore address copy
00002510  0280 000000FF           1782              ANDI.L      #mask_byte4,D0          * isolate byte one
00002516  4EB8 234E               1783              JSR         hexToA                  * convert byte and copy to buffer
0000251A  301C                    1784              MOVE.W      (A4)+,D0                * load word from memory
0000251C  45F9 00002748           1785              LEA         good_buffer,A2          * reload good_buffer
00002522  47F9 0000279A           1786              LEA         bad_buffer,A3           * reload bad_buffer
00002528  26DA                    1787              MOVE.L      (A2)+,(A3)+             * copy first "word" from good_buffer
0000252A  26DA                    1788              MOVE.L      (A2)+,(A3)+             * copy second "word" from good_buffer
0000252C  14FC 0020               1789              MOVE.B      #space,(A2)+            * add space to good_buffer
00002530  14FC 001A               1790              MOVE.B      #sub,(A2)+              * add substitution to good_buffer / done
00002534  2C4A                    1791              MOVEA.L     A2,A6                   * store current position of pointer
00002536  244B                    1792  switch      MOVEA.L     A3,A2                   * load register with bad_buffer
00002538  14FC 0020               1793              MOVE.B      #space,(A2)+            * add space to bad_buffer
0000253C  14FC 001A               1794              MOVE.B      #sub,(A2)+              * add substitution to bad_buffer
00002540  41F9 0000271C           1795              LEA         move_stor,A0            * load storage
00002546  5888                    1796              ADDA.L      #4,A0                   * add displacement value to address
00002548  24D0                    1797              MOVE.L      (A0),(A2)+              * copy long from storage to buffer
0000254A  14FC 0020               1798              MOVE.B      #space,(A2)+            * add space to buffer
0000254E  14FC 0024               1799              MOVE.B      #hex,(A2)+              * add $ to buffer
00002552  3200                    1800              MOVE.W      D0,D1                   * copy word to register D1
00002554  0280 0000FF00           1801              ANDI.L      #mask_byte3,D0          * isolate byte 2
0000255A  E098                    1802              ROR.L       #8,D0                   * shift to LSB position
0000255C  4EB8 234E               1803              JSR         hexToA                  * convert and copy to buffer
00002560  3001                    1804              MOVE.W      D1,D0                   * copy word to register D0
00002562  0280 000000FF           1805              ANDI.L      #mask_byte4,D0          * isolate byte 1
00002568  4EB8 234E               1806              JSR         hexToA                  * convert and copy to buffer
0000256C  14FC 000A               1807              MOVE.B      #newline,(A2)+          * add new line to buffer
00002570  14FC 000D               1808              MOVE.B      #return,(A2)+           * add carriage return to buffer
00002574  3001                    1809              MOVE.W      D1,D0                   * copy to register D0
00002576  244E                    1810              MOVE.L      A6,A2                   * restore good_buffer pointer to A2
00002578  7200                    1811              MOVE.L      #empty,D1               * clear register
0000257A  267C 00000000           1812              MOVE.L      #empty,A3               * clear register
00002580  4E75                    1813              RTS                                 * return to program main
00002582                          1814  *-------------------------------------------------------------------------------
00002582                          1815  * Subroutine: clearReg
00002582                          1816  * Description: Will zero the following registers: A0-A3,A6 / D0-D7
00002582                          1817  *              Registers A4 and A5 are skipped because they contain the address
00002582                          1818  *              boundries entered by the user.
00002582                          1819  * API: None
00002582                          1820  *-------------------------------------------------------------------------------    
00002582  7000                    1821  clearReg    MOVE.L      #empty,D0               * clear register
00002584  7200                    1822              MOVE.L      #empty,D1               * clear register
00002586  7400                    1823              MOVE.L      #empty,D2               * clear register
00002588  7600                    1824              MOVE.L      #empty,D3               * clear register
0000258A  7800                    1825              MOVE.L      #empty,D4               * clear register
0000258C  7A00                    1826              MOVE.L      #empty,D5               * clear register
0000258E  7C00                    1827              MOVE.L      #empty,D6               * clear register
00002590  7E00                    1828              MOVE.L      #empty,D7               * clear register
00002592  207C 00000000           1829              MOVE.L      #empty,A0               * clear register
00002598  227C 00000000           1830              MOVE.L      #empty,A1               * clear register
0000259E  247C 00000000           1831              MOVE.L      #empty,A2               * clear register
000025A4  267C 00000000           1832              MOVE.L      #empty,A3               * clear register
000025AA  2C7C 00000000           1833              MOVE.L      #empty,A6               * clear register
000025B0  4E75                    1834              RTS                                 * return to program main
000025B2                          1835              
000025B2                          1836  *-------------------------------------------------------------------------------
000025B2                          1837  * Subroutine: clearSome
000025B2                          1838  * Description: Will zero the following registers: A0,A1,A3,A6 / D1-D7
000025B2                          1839  *              Registers A4 and A5 are skipped because they contain the address
000025B2                          1840  *              boundries entered by the user.
000025B2                          1841  * API: None
000025B2                          1842  *-------------------------------------------------------------------------------    
000025B2  7200                    1843  clearSome   MOVE.L      #empty,D1               * clear register
000025B4  7400                    1844              MOVE.L      #empty,D2               * clear register
000025B6  7600                    1845              MOVE.L      #empty,D3               * clear register
000025B8  7800                    1846              MOVE.L      #empty,D4               * clear register
000025BA  7A00                    1847              MOVE.L      #empty,D5               * clear register
000025BC  7C00                    1848              MOVE.L      #empty,D6               * clear register
000025BE  7E00                    1849              MOVE.L      #empty,D7               * clear register
000025C0  207C 00000000           1850              MOVE.L      #empty,A0               * clear register
000025C6  227C 00000000           1851              MOVE.L      #empty,A1               * clear register
000025CC  267C 00000000           1852              MOVE.L      #empty,A3               * clear register
000025D2  2C7C 00000000           1853              MOVE.L      #empty,A6               * clear register
000025D8  4E75                    1854              RTS                                 * return to program main
000025DA                          1855  *-------------------------------------------------------------------------------
000025DA                          1856  * Subroutine: display
000025DA                          1857  * Description: Will display information header for program and will display box
000025DA                          1858  *              with criteria for valid addresses.
000025DA                          1859  * API: A1 - used internally for Trap statement (pointer to notes)
000025DA                          1860  *      D0 - used internally for Trap statement (display note)
000025DA                          1861  *      D1 - used internally for Trap statement (note length)
000025DA                          1862  *-------------------------------------------------------------------------------
000025DA  103C 0000               1863  display     MOVE.B      #tsk0,D0                * load task
000025DE  43F9 000027EC           1864  head1       LEA         header1,A1              * address of string
000025E4  3239 00002838           1865              MOVE.W      head_len1,D1            * length of string
000025EA  4E4F                    1866              TRAP        #15                     * display first
000025EC  43F9 0000283A           1867  head2       LEA         header2,A1              * address of string
000025F2  3239 00002888           1868              MOVE.W      head_len2,D1            * length of string
000025F8  4E4F                    1869              TRAP        #15                     * display second
000025FA  43F9 0000288A           1870  head3       LEA         header3,A1              * address of string
00002600  3239 000028D6           1871              MOVE.W      head_len3,D1            * length of string
00002606  4E4F                    1872              TRAP        #15                     * display third
00002608  43F9 000028D8           1873  head4       LEA         header4,A1              * address of string
0000260E  3239 00002924           1874              MOVE.W      head_len4,D1            * length of string
00002614  4E4F                    1875              TRAP        #15                     * display fourth
00002616  43F9 00002926           1876  head5       LEA         header5,A1              * address of string
0000261C  3239 00002972           1877              MOVE.W      head_len5,D1            * length of string
00002622  4E4F                    1878              TRAP        #15                     * display fifth
00002624  43F9 00002974           1879  head6       LEA         header6,A1              * address of string
0000262A  3239 000029C2           1880              MOVE.W      head_len6,D1            * length of string
00002630  4E4F                    1881              TRAP        #15                     * display sixth         
00002632                          1882              
00002632  43F9 000029C4           1883  valid1      LEA         v_msg1,A1               * address of string
00002638  3239 000029E2           1884              MOVE.W      v_len1,D1               * length of string
0000263E  4E4F                    1885              TRAP        #15                     * display first
00002640  43F9 000029E4           1886  valid2      LEA         v_msg2,A1               * address of string
00002646  3239 00002A12           1887              MOVE.W      v_len2,D1               * length of string
0000264C  4E4F                    1888              TRAP        #15                     * display second
0000264E  43F9 00002A14           1889  valid3      LEA         v_msg3,A1               * address of string
00002654  3239 00002A4A           1890              MOVE.W      v_len3,D1               * length of string
0000265A  4E4F                    1891              TRAP        #15                     * display third
0000265C  43F9 00002A4C           1892  valid4      LEA         v_msg4,A1               * address of string
00002662  3239 00002A7A           1893              MOVE.W      v_len4,D1               * length of string
00002668  4E4F                    1894              TRAP        #15                     * display fourth
0000266A  4E75                    1895              RTS                                 * return to program main
0000266C                          1896  *-------------------------------------------------------------------------------
0000266C                          1897  *
0000266C                          1898  *           DATA AREA
0000266C                          1899  *
0000266C                          1900  *-------------------------------------------------------------------------------
0000266C                          1901  s_addr      DS.L        2                       * stores starting address
00002674                          1902  e_addr      DS.L        2                       * stores ending address
0000267C                          1903  exit        DS.B        1                       * stores user input for exit query
0000267D= 00                      1904  counter     DC.B        0                       * counter for loops
0000267E= 00                      1905  p_count     DC.B        0                       * counts lines for page display
0000267F= 00                      1906  flag        DC.B        0                       * program state (GOOD == 00 / BAD = FF)
00002680                          1907  
00002680= 0000 0001 0010 0...     1908  bin_pattern DC.W        $0000,$0001,$0010,$0011,$0100,$0101,$0110,$0111,$1000,$1001,$1010,$1011,$1100,$1101,$1110,$1111
000026A0                          1909  bin_storage DS.W        16                      * storage for binary
000026C0                          1910  
000026C0                          1911  * buffer elements
000026C0= 41 44 44 2E 41 44 ...   1912  math_stor   DC.B        'ADD.','ADDA','ADDI','SUB.','SUBA','SUBI'
000026D8= 41 4E 44 49 43 4D ...   1913  immi_stor   DC.B        'ANDI','CMPI','EORI','ORI',$1A
000026E8= 41 4E 44 2E 4F 52 ...   1914  lgic_stor   DC.B        'AND.','OR.',$1A,'EXG',$20
000026F4= 41 53 4C 1A 41 53 ...   1915  mani_stor   DC.B        'ASL',$1A,'ASR',$1A,'LSL',$1A,'LSR',$1A,'ROL',$1A,'ROR',$1A
0000270C= 43 4D 50 2E 43 4D ...   1916  comp_stor   DC.B        'CMP.','CMPA','EOR.'
00002718= 42 53 52 1A             1917  brch_stor   DC.B        'BSR',$1A
0000271C= 4D 4F 56 45 44 41 ...   1918  move_stor   DC.B        'MOVE','DATA'
00002724= 43 4C 52 2E 4A 53 ...   1919  spec_stor   DC.B        'CLR.','JSR',$20,'JMP',$20,'LEA',$20,'NEG',$20,'NOP',$1A,'NOT.','RTS',$1A,'SWAP'
00002748                          1920  
00002748                          1921  * display message buffers
00002748                          1922  good_buffer DS.B        80                                  * good buffer
00002798= 0050                    1923  gb_size     DC.W        gb_size-good_buffer                 * size of good buffer
0000279A                          1924  bad_buffer  DS.B        80                                  * bad buffer
000027EA= 0050                    1925  bb_size     DC.W        bb_size-bad_buffer                  * size of bad buffer
000027EC                          1926  
000027EC                          1927  * header strings
000027EC= 2A 2A 2A 2A 2A 2A ...   1928  header1     DC.B        '****************************************************************************'
00002838= 004C                    1929  head_len1   DC.W        head_len1-header1
0000283A= 2A 20 43 53 53 20 ...   1930  header2     DC.B        '* CSS 422 - Spring 2010   |   Motorola 68K Disassembler (ver 3.2.2)          *'
00002888= 004E                    1931  head_len2   DC.W        head_len2-header2
0000288A= 2A 20 2D 20 41 61 ...   1932  header3     DC.B        '* - Aaron Parks                                                            *'
000028D6= 004C                    1933  head_len3   DC.W        head_len3-header3
000028D8= 2A 20 2D 20 4E 65 ...   1934  header4     DC.B        '* - Neal Natsheh                                                           *'
00002924= 004C                    1935  head_len4   DC.W        head_len4-header4
00002926= 2A 20 2D 20 4D 61 ...   1936  header5     DC.B        '* - Mark Shipman                                                           *'
00002972= 004C                    1937  head_len5   DC.W        head_len5-header5
00002974= 2A 2A 2A 2A 2A 2A ...   1938  header6     DC.B        '****************************************************************************',$0A
000029C2= 004E                    1939  head_len6   DC.W        head_len6-header6
000029C4                          1940  
000029C4                          1941  * reminder messages
000029C4= 20 4E 6F 74 65 73 ...   1942  v_msg1      DC.B        ' Notes about valid addresses: '
000029E2= 001E                    1943  v_len1      DC.W        v_len1-v_msg1
000029E4= 2D 3E 20 49 6E 70 ...   1944  v_msg2      DC.B        '-> Input too short will be appended with zeros'
00002A12= 002E                    1945  v_len2      DC.W        v_len2-v_msg2
00002A14= 2D 3E 20 4F 6E 6C ...   1946  v_msg3      DC.B        '-> Only the last eight charcters of input will be used'
00002A4A= 0036                    1947  v_len3      DC.W        v_len3-v_msg3
00002A4C= 2D 3E 20 41 6E 79 ...   1948  v_msg4      DC.B        '-> Any odd address will be converted to even',$0A
00002A7A= 002E                    1949  v_len4      DC.W        v_len4-v_msg4
00002A7C= 20 20 20 44 69 73 ...   1950  v_msg5      DC.B        '   Disassembly Complete!'
00002A94= 0018                    1951  v_len5      DC.W        v_len5-v_msg5
00002A96= 20 20 20 57 6F 75 ...   1952  v_msg6      DC.B        '   Would you like to disassemble again?'
00002ABE= 0028                    1953  v_len6      DC.W        v_len6-v_msg6
00002AC0= 20 20 20 50 72 65 ...   1954  v_msg7      DC.B        '   Press <Enter> to Continue',$0A
00002ADE= 001E                    1955  v_len7      DC.W        v_len7-v_msg7
00002AE0                          1956  
00002AE0                          1957  * user prompts
00002AE0= 45 6E 74 65 72 20 ...   1958  prompt1     DC.B        'Enter starting address (greater than $00001000): '
00002B12= 0032                    1959  p_len1      DC.W        p_len1-prompt1                      
00002B14= 45 6E 74 65 72 20 ...   1960  prompt2     DC.B        'Enter ending address (less than $000FFFFF): '
00002B40= 002C                    1961  p_len2      DC.W        p_len2-prompt2
00002B42= 20 20 20 3C 59 20 ...   1962  prompt3     DC.B        '   <Y or y> YES     <Any Key> Exit'
00002B64= 0022                    1963  p_len3      DC.W        p_len3-prompt3                                              
00002B66                          1964  
00002B66                          1965  * error messages
00002B66= 20 20 20 45 72 72 ...   1966  error1      DC.B        '   Error: Address must be greater than $00001000',$0A,$0D
00002B98= 0032                    1967  e_len1      DC.W        e_len1-error1
00002B9A= 20 20 20 45 72 72 ...   1968  error2      DC.B        '   Error: Address must be less than $000FFFFF',$0D,$0A
00002BCA= 0030                    1969  e_len2      DC.W        e_len2-error2
00002BCC= 20 20 20 45 72 72 ...   1970  error3      DC.B        '   Error: Address range too small',$0D,$0A
00002BF0= 0024                    1971  e_len3      DC.W        e_len3-error3
00002BF2= 20 20 20 45 72 72 ...   1972  error4      DC.B        '   Error: Ending address must be at least one word greater than starting address',$0D,$0A
00002C44= 0052                    1973  e_len4      DC.W        e_len4-error4
00002C46                          1974  
00002C46= 00                      1975  s_a_l       DC.B        0                                   * Starting Address Length
00002C47= 00                      1976  e_a_l       DC.B        0                                   * Ending Address Length
00002C48                          1977  
00002C48                          1978              END         $1000

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDA_EA_DN          13A8
ADDA_S_L            1410
ADDA_S_W            140A
ADDCNT              4
ADDI_               145C
ADDI_OPCODE         110
ADDR_MASK1          F0
ADDR_MASK2          F
ADD_                12A4
ADD_DN_EA           12E4
ADD_EA_DN           1344
ANDI_               1474
ANDI_OPCODE         10
AND_MASK1           F
AND_MASK2           FFFFF000
AND_MASK3           FF00
AND_MASK4           FFF0
AND_MASK5           FFF
ANE_                17B2
ANE_EA_DN           1978
ANN_DN_EA           1900
APPENDS             2276
APP_DONE            22A2
ARITH_MASK1         FFF00
ARITH_MASK2         FFF00000
ARITH_MASK3         FF
ARITH_MASK4         FFFFFF
ARITH_MASK5         FFF0
ASAPRIGHT           1DD6
ASHIFT              1DB2
B35_MASK            38
B37_MASK            78
B45_MASK            30
B68_MASK            1C0
B911_MASK           E00
BAD                 FF
BAD_BUFFER          279A
BB_SIZE             27EA
BIN                 25
BIN_PATTERN         2680
BIN_STORAGE         26A0
BIN_TO_DEC          23A6
BIT6_MASK           40
BIT8_MASK           100
BIT9_MASK           200
BRANCHSR_           15E8
BRCH_STOR           2718
BRNCH_              15D2
BSR_16              1646
BSR_32              1668
BSR_MASK1           FFFF0000
BSR_MASK2           FFFF
BTD_DONE            23B0
BYTE                42
BYTE_1              250E
BYTE_2              2500
BYTE_3              24F0
BYTE_4              24E4
CHECK_2             22C8
CLEARREG            2582
CLEARSOME           25B2
CLP                 29
CLR_                1FF0
CMPA_               1C04
CMPA_L              1CDA
CMPA_W              1CD2
CMPI_               148A
CMPI_OPCODE         1100
CMPSR               1B60
CMP_                1B98
CNVT_DONE           2346
COMMA               2C
COMP_STOR           270C
CONT_ADDA           13C2
CONT_CMPA           1C1E
CONT_SUBA           1B0C
CONVERT             22EC
COUNTER             267D
DEC_CNT             1
DISPLAY             25DA
DOT                 2E
DSPACE              2020
EA_MASK0            3F
EA_MASK1            FFF000
EA_MASK2            FFF
EA_MASK3            FC0
EMPTY               0
EMPTY_CNT           0
END_BNDS            FFFFF
ENTER_              10F8
EORI_               14A2
EORI_OPCODE         1010
EOR_                1C68
ERROR1              2B66
ERROR2              2B9A
ERROR3              2BCC
ERROR4              2BF2
EXG_ADD             184C
EXG_DN              17F2
EXG_D_A             18A6
EXIT                267C
E_ADDR              2674
E_A_L               2C47
E_LEN1              2B98
E_LEN2              2BCA
E_LEN3              2BF0
E_LEN4              2C44
FLAG                267F
FNL_MSG1            1242
FNL_MSG2            1254
FST_CHK             1098
GB_SIZE             2798
GENEA               20BA
GENEA_DONE          21A6
GEN_MASK            FFFFFF00
GEN_TYPE            1138
GETOUT              23A4
GETSIZE             2460
GOOD                0
GOOD_BUFFER         2748
GS_B                248A
GS_DONE             24A2
GS_L                249E
GS_W                2494
HEAD1               25DE
HEAD2               25EC
HEAD3               25FA
HEAD4               2608
HEAD5               2616
HEAD6               2624
HEADER1             27EC
HEADER2             283A
HEADER3             288A
HEADER4             28D8
HEADER5             2926
HEADER6             2974
HEAD_LEN1           2838
HEAD_LEN2           2888
HEAD_LEN3           28D6
HEAD_LEN4           2924
HEAD_LEN5           2972
HEAD_LEN6           29C2
HEX                 24
HEXTOA              234E
HEXTOAJMP           2356
HTOAMASK_1          FF00
HTOAMASK_2          FF
IMMI_STOR           26D8
IMMSIZE             14F2
IMMSR               1416
IMM_BYTE            1514
IMM_LONG            1560
IMM_MASK1           FF000000
IMM_MASK2           FFFFFF
IMM_WORD            1532
INCREMENT           1
INI_BUFFERS         1118
ISBYTE              2296
ISLONG              228E
ISVALID             22A4
ISWORD              229E
JMP_                208E
JSR_                207A
LEA_                1FB6
LEA_REG             23B2
LETR_CONV           2394
LETR_CONV2          239C
LGIC_STOR           26E8
LLOOP               22F4
LONG                4C
LOOP                2
LR_DONE             23DC
LSHIFT              1DE0
LSRIGHT             1E06
LST_CHK             10B2
L_KEY               57
MAIN                10D8
MANIJMP2            1EA8
MANIPJMP1           1E4C
MANIP_              1D80
MANIP_MASK1         FF00
MANIP_MASK2         FF000
MANIP_MASK3         F
MANIP_MASK4         F00000
MANIP_MASK5         FFF0
MANIP_MASK6         FFF
MANIP_MASK7         FF000000
MANIP_MASK8         FFFFFF
MANI_APD            1EA4
MANI_EA             1EF4
MANI_STOR           26F4
MASK_BYTE1          FF000000
MASK_BYTE2          FF0000
MASK_BYTE3          FF00
MASK_BYTE4          FF
MASK_EVEN           FFFFFFFE
MASK_LEFT           F0
MASK_RIGHT          F
MATH_STOR           26C0
MEM2REG             245E
MINUS               2D
MMSR_DONE           245E
MODE0               0
MODE1               1
MODE2               10
MODE3               11
MODE4               100
MODE5               101
MODE6               110
MODE7               111
MODE_AN             2132
MODE_ANDEC          216A
MODE_ANIN           213E
MODE_ANINX          2182
MODE_ANPLUS         2152
MODE_DN             2126
MODE_SVN            21A0
MOVEAL_             1D28
MOVEASR             240E
MOVEAW_             1D6A
MOVEB_              1CE2
MOVEL_              1CFC
MOVEMSR             2440
MOVEM_              2058
MOVESR              23DE
MOVEW_              1D3E
MOVE_STOR           271C
MOVM_MASK           400
NEG_                2000
NEWLINE             A
NLOOP               2334
NOP_                1F9A
NOP_OPCODE          4D71
NOT_                2016
NUM                 23
N_KEY               30
OPMD_MASK           1C0
OPP                 28
OP_TYPE             1176
ORI_                14BA
ORI_OPCODE          0
OR_                 16A8
OR_DN_EA            16EE
OR_EA_DN            174E
PATTCNT             2
PLUS                2B
PRGM_DONE           12A0
PRGM_START          1000
PRINTER             1228
PRNTTOSCRN          1200
PRNT_GOOD           1222
PROMPT1             2AE0
PROMPT2             2B14
PROMPT3             2B42
P_COUNT             267E
P_LEN1              2B12
P_LEN2              2B40
P_LEN3              2B64
QSPACE              20202020
REG0                0
REG1                1
REG2MEM             2458
REG4                4
REG_FOUR            2236
REG_LONG            21D0
REG_MASK            E00
REG_WORD            2212
RESET               0
RESUMEIMM           15AC
RETURN              D
RF_NEXT             2256
RF_ZERO_            2270
ROTATE              1E14
ROTRIGHT            1E3E
RTS_                1FA8
RTS_OPCODE          4D75
R_NIB               2382
SB_CLR              24BE
SB_NEXT             24D8
SETBAD              11F2
SETBUFFERS          24AC
SET_BAD             22EA
SET_GOOD            22E8
SHIFT               4
SIZE_MASK           C0
SMS_DONE            2274
SPACE               20
SPC_DONE            20B6
SPC_EA              20A0
SPECL_              1F12
SPEC_STOR           2724
SP_SIZE             23D4
START_BNDS          1000
STK_PTR             A00000
SUB                 1A
SUBA_EA_DN          1AEE
SUBA_S_L            1B5A
SUBA_S_W            1B54
SUBI_               14D6
SUBI_OPCODE         100
SUBMODESVN          21A8
SUB_                19E4
SUB_DN_EA           1A2A
SUB_EA_DN           1A8A
SUB_MAIN            10D0
SWAP_               202C
SWAP_MASK           7
SWITCH              2536
S_ADDR              266C
S_A_L               2C46
TSK0                0
TSK1                1
TSK2                2
ULOOP               231A
USR_INPT1           101E
USR_INPT2           1064
USR_INPT3           1278
USR_PRMPT1          100C
USR_PRMPT2          1052
USR_PRMPT3          1266
U_KEY               37
VALID1              2632
VALID2              2640
VALID3              264E
VALID4              265C
V_LEN1              29E2
V_LEN2              2A12
V_LEN3              2A4A
V_LEN4              2A7A
V_LEN5              2A94
V_LEN6              2ABE
V_LEN7              2ADE
V_MSG1              29C4
V_MSG2              29E4
V_MSG3              2A14
V_MSG4              2A4C
V_MSG5              2A7C
V_MSG6              2A96
V_MSG7              2AC0
WORD                57
YES1                59
YES2                79
